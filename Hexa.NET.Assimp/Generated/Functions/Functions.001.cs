// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.Assimp
{
	public unsafe partial class Assimp
	{

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a floating-point property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyFloat(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyFloat")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyFloat([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] ref AiPropertyStore store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] byte* szName, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "ai_real")] double value)
		{
			fixed (AiPropertyStore* pstore = &store)
			{
				SetImportPropertyFloatNative((AiPropertyStore*)pstore, szName, value);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a floating-point property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyFloat(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyFloat")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyFloat([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] ref byte szName, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "ai_real")] double value)
		{
			fixed (byte* pszName = &szName)
			{
				SetImportPropertyFloatNative(store, (byte*)pszName, value);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a floating-point property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyFloat(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyFloat")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyFloat([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> szName, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "ai_real")] double value)
		{
			fixed (byte* pszName = szName)
			{
				SetImportPropertyFloatNative(store, (byte*)pszName, value);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a floating-point property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyFloat(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyFloat")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyFloat([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] string szName, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "ai_real")] double value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (szName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(szName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(szName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetImportPropertyFloatNative(store, pStr0, value);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a floating-point property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyFloat(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyFloat")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyFloat([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] ref AiPropertyStore store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] ref byte szName, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "ai_real")] double value)
		{
			fixed (AiPropertyStore* pstore = &store)
			{
				fixed (byte* pszName = &szName)
				{
					SetImportPropertyFloatNative((AiPropertyStore*)pstore, (byte*)pszName, value);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a floating-point property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyFloat(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyFloat")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyFloat([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] ref AiPropertyStore store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> szName, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "ai_real")] double value)
		{
			fixed (AiPropertyStore* pstore = &store)
			{
				fixed (byte* pszName = szName)
				{
					SetImportPropertyFloatNative((AiPropertyStore*)pstore, (byte*)pszName, value);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a floating-point property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyFloat(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyFloat")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyFloat([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] ref AiPropertyStore store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] string szName, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "ai_real")] double value)
		{
			fixed (AiPropertyStore* pstore = &store)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (szName != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(szName);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(szName, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SetImportPropertyFloatNative((AiPropertyStore*)pstore, pStr0, value);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a string property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyString(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyString")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetImportPropertyStringNative([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] byte* szName, [NativeName(NativeNameType.Param, "st")] [NativeName(NativeNameType.Type, "aiString const *")] AiString* st)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<AiPropertyStore*, byte*, AiString*, void>)funcTable[31])(store, szName, st);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[31])((nint)store, (nint)szName, (nint)st);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a string property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyString(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyString([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] byte* szName, [NativeName(NativeNameType.Param, "st")] [NativeName(NativeNameType.Type, "aiString const *")] AiString* st)
		{
			SetImportPropertyStringNative(store, szName, st);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a string property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyString(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyString([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] ref AiPropertyStore store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] byte* szName, [NativeName(NativeNameType.Param, "st")] [NativeName(NativeNameType.Type, "aiString const *")] AiString* st)
		{
			fixed (AiPropertyStore* pstore = &store)
			{
				SetImportPropertyStringNative((AiPropertyStore*)pstore, szName, st);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a string property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyString(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyString([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] ref byte szName, [NativeName(NativeNameType.Param, "st")] [NativeName(NativeNameType.Type, "aiString const *")] AiString* st)
		{
			fixed (byte* pszName = &szName)
			{
				SetImportPropertyStringNative(store, (byte*)pszName, st);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a string property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyString(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyString([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> szName, [NativeName(NativeNameType.Param, "st")] [NativeName(NativeNameType.Type, "aiString const *")] AiString* st)
		{
			fixed (byte* pszName = szName)
			{
				SetImportPropertyStringNative(store, (byte*)pszName, st);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a string property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyString(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyString([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] string szName, [NativeName(NativeNameType.Param, "st")] [NativeName(NativeNameType.Type, "aiString const *")] AiString* st)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (szName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(szName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(szName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetImportPropertyStringNative(store, pStr0, st);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a string property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyString(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyString([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] ref AiPropertyStore store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] ref byte szName, [NativeName(NativeNameType.Param, "st")] [NativeName(NativeNameType.Type, "aiString const *")] AiString* st)
		{
			fixed (AiPropertyStore* pstore = &store)
			{
				fixed (byte* pszName = &szName)
				{
					SetImportPropertyStringNative((AiPropertyStore*)pstore, (byte*)pszName, st);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a string property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyString(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyString([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] ref AiPropertyStore store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> szName, [NativeName(NativeNameType.Param, "st")] [NativeName(NativeNameType.Type, "aiString const *")] AiString* st)
		{
			fixed (AiPropertyStore* pstore = &store)
			{
				fixed (byte* pszName = szName)
				{
					SetImportPropertyStringNative((AiPropertyStore*)pstore, (byte*)pszName, st);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a string property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyString(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyString([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] ref AiPropertyStore store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] string szName, [NativeName(NativeNameType.Param, "st")] [NativeName(NativeNameType.Type, "aiString const *")] AiString* st)
		{
			fixed (AiPropertyStore* pstore = &store)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (szName != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(szName);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(szName, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SetImportPropertyStringNative((AiPropertyStore*)pstore, pStr0, st);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a string property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyString(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyString([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] byte* szName, [NativeName(NativeNameType.Param, "st")] [NativeName(NativeNameType.Type, "aiString const *")] ref AiString st)
		{
			fixed (AiString* pst = &st)
			{
				SetImportPropertyStringNative(store, szName, (AiString*)pst);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a string property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyString(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyString([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] ref AiPropertyStore store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] byte* szName, [NativeName(NativeNameType.Param, "st")] [NativeName(NativeNameType.Type, "aiString const *")] ref AiString st)
		{
			fixed (AiPropertyStore* pstore = &store)
			{
				fixed (AiString* pst = &st)
				{
					SetImportPropertyStringNative((AiPropertyStore*)pstore, szName, (AiString*)pst);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a string property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyString(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyString([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] ref byte szName, [NativeName(NativeNameType.Param, "st")] [NativeName(NativeNameType.Type, "aiString const *")] ref AiString st)
		{
			fixed (byte* pszName = &szName)
			{
				fixed (AiString* pst = &st)
				{
					SetImportPropertyStringNative(store, (byte*)pszName, (AiString*)pst);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a string property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyString(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyString([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> szName, [NativeName(NativeNameType.Param, "st")] [NativeName(NativeNameType.Type, "aiString const *")] ref AiString st)
		{
			fixed (byte* pszName = szName)
			{
				fixed (AiString* pst = &st)
				{
					SetImportPropertyStringNative(store, (byte*)pszName, (AiString*)pst);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a string property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyString(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyString([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] string szName, [NativeName(NativeNameType.Param, "st")] [NativeName(NativeNameType.Type, "aiString const *")] ref AiString st)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (szName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(szName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(szName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (AiString* pst = &st)
			{
				SetImportPropertyStringNative(store, pStr0, (AiString*)pst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a string property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyString(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyString([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] ref AiPropertyStore store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] ref byte szName, [NativeName(NativeNameType.Param, "st")] [NativeName(NativeNameType.Type, "aiString const *")] ref AiString st)
		{
			fixed (AiPropertyStore* pstore = &store)
			{
				fixed (byte* pszName = &szName)
				{
					fixed (AiString* pst = &st)
					{
						SetImportPropertyStringNative((AiPropertyStore*)pstore, (byte*)pszName, (AiString*)pst);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a string property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyString(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyString([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] ref AiPropertyStore store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> szName, [NativeName(NativeNameType.Param, "st")] [NativeName(NativeNameType.Type, "aiString const *")] ref AiString st)
		{
			fixed (AiPropertyStore* pstore = &store)
			{
				fixed (byte* pszName = szName)
				{
					fixed (AiString* pst = &st)
					{
						SetImportPropertyStringNative((AiPropertyStore*)pstore, (byte*)pszName, (AiString*)pst);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a string property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyString(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyString([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] ref AiPropertyStore store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] string szName, [NativeName(NativeNameType.Param, "st")] [NativeName(NativeNameType.Type, "aiString const *")] ref AiString st)
		{
			fixed (AiPropertyStore* pstore = &store)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (szName != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(szName);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(szName, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (AiString* pst = &st)
				{
					SetImportPropertyStringNative((AiPropertyStore*)pstore, pStr0, (AiString*)pst);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a matrix property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyMatrix(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetImportPropertyMatrixNative([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] byte* szName, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<AiPropertyStore*, byte*, Matrix4x4*, void>)funcTable[32])(store, szName, mat);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[32])((nint)store, (nint)szName, (nint)mat);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a matrix property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyMatrix(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyMatrix([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] byte* szName, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat)
		{
			SetImportPropertyMatrixNative(store, szName, mat);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a matrix property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyMatrix(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyMatrix([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] ref AiPropertyStore store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] byte* szName, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat)
		{
			fixed (AiPropertyStore* pstore = &store)
			{
				SetImportPropertyMatrixNative((AiPropertyStore*)pstore, szName, mat);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a matrix property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyMatrix(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyMatrix([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] ref byte szName, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat)
		{
			fixed (byte* pszName = &szName)
			{
				SetImportPropertyMatrixNative(store, (byte*)pszName, mat);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a matrix property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyMatrix(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyMatrix([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> szName, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat)
		{
			fixed (byte* pszName = szName)
			{
				SetImportPropertyMatrixNative(store, (byte*)pszName, mat);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a matrix property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyMatrix(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyMatrix([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] string szName, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (szName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(szName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(szName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetImportPropertyMatrixNative(store, pStr0, mat);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a matrix property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyMatrix(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyMatrix([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] ref AiPropertyStore store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] ref byte szName, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat)
		{
			fixed (AiPropertyStore* pstore = &store)
			{
				fixed (byte* pszName = &szName)
				{
					SetImportPropertyMatrixNative((AiPropertyStore*)pstore, (byte*)pszName, mat);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a matrix property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyMatrix(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyMatrix([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] ref AiPropertyStore store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> szName, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat)
		{
			fixed (AiPropertyStore* pstore = &store)
			{
				fixed (byte* pszName = szName)
				{
					SetImportPropertyMatrixNative((AiPropertyStore*)pstore, (byte*)pszName, mat);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a matrix property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyMatrix(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyMatrix([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] ref AiPropertyStore store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] string szName, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat)
		{
			fixed (AiPropertyStore* pstore = &store)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (szName != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(szName);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(szName, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SetImportPropertyMatrixNative((AiPropertyStore*)pstore, pStr0, mat);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a matrix property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyMatrix(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyMatrix([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] byte* szName, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				SetImportPropertyMatrixNative(store, szName, (Matrix4x4*)pmat);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a matrix property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyMatrix(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyMatrix([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] ref AiPropertyStore store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] byte* szName, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat)
		{
			fixed (AiPropertyStore* pstore = &store)
			{
				fixed (Matrix4x4* pmat = &mat)
				{
					SetImportPropertyMatrixNative((AiPropertyStore*)pstore, szName, (Matrix4x4*)pmat);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a matrix property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyMatrix(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyMatrix([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] ref byte szName, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat)
		{
			fixed (byte* pszName = &szName)
			{
				fixed (Matrix4x4* pmat = &mat)
				{
					SetImportPropertyMatrixNative(store, (byte*)pszName, (Matrix4x4*)pmat);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a matrix property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyMatrix(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyMatrix([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> szName, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat)
		{
			fixed (byte* pszName = szName)
			{
				fixed (Matrix4x4* pmat = &mat)
				{
					SetImportPropertyMatrixNative(store, (byte*)pszName, (Matrix4x4*)pmat);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a matrix property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyMatrix(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyMatrix([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] string szName, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (szName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(szName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(szName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Matrix4x4* pmat = &mat)
			{
				SetImportPropertyMatrixNative(store, pStr0, (Matrix4x4*)pmat);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a matrix property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyMatrix(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyMatrix([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] ref AiPropertyStore store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] ref byte szName, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat)
		{
			fixed (AiPropertyStore* pstore = &store)
			{
				fixed (byte* pszName = &szName)
				{
					fixed (Matrix4x4* pmat = &mat)
					{
						SetImportPropertyMatrixNative((AiPropertyStore*)pstore, (byte*)pszName, (Matrix4x4*)pmat);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a matrix property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyMatrix(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyMatrix([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] ref AiPropertyStore store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> szName, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat)
		{
			fixed (AiPropertyStore* pstore = &store)
			{
				fixed (byte* pszName = szName)
				{
					fixed (Matrix4x4* pmat = &mat)
					{
						SetImportPropertyMatrixNative((AiPropertyStore*)pstore, (byte*)pszName, (Matrix4x4*)pmat);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a matrix property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyMatrix(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyMatrix([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] ref AiPropertyStore store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] string szName, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat)
		{
			fixed (AiPropertyStore* pstore = &store)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (szName != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(szName);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(szName, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Matrix4x4* pmat = &mat)
				{
					SetImportPropertyMatrixNative((AiPropertyStore*)pstore, pStr0, (Matrix4x4*)pmat);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a quaternion from a 3x3 rotation matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiCreateQuaternionFromMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateQuaternionFromMatrixNative([NativeName(NativeNameType.Param, "quat")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* quat, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] Matrix3x3* mat)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Quaternion*, Matrix3x3*, void>)funcTable[33])(quat, mat);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[33])((nint)quat, (nint)mat);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a quaternion from a 3x3 rotation matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiCreateQuaternionFromMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CreateQuaternionFromMatrix([NativeName(NativeNameType.Param, "quat")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* quat, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] Matrix3x3* mat)
		{
			CreateQuaternionFromMatrixNative(quat, mat);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a quaternion from a 3x3 rotation matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiCreateQuaternionFromMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CreateQuaternionFromMatrix([NativeName(NativeNameType.Param, "quat")] [NativeName(NativeNameType.Type, "aiQuaternion *")] ref Quaternion quat, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] Matrix3x3* mat)
		{
			fixed (Quaternion* pquat = &quat)
			{
				CreateQuaternionFromMatrixNative((Quaternion*)pquat, mat);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a quaternion from a 3x3 rotation matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiCreateQuaternionFromMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CreateQuaternionFromMatrix([NativeName(NativeNameType.Param, "quat")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* quat, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] ref Matrix3x3 mat)
		{
			fixed (Matrix3x3* pmat = &mat)
			{
				CreateQuaternionFromMatrixNative(quat, (Matrix3x3*)pmat);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a quaternion from a 3x3 rotation matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiCreateQuaternionFromMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CreateQuaternionFromMatrix([NativeName(NativeNameType.Param, "quat")] [NativeName(NativeNameType.Type, "aiQuaternion *")] ref Quaternion quat, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] ref Matrix3x3 mat)
		{
			fixed (Quaternion* pquat = &quat)
			{
				fixed (Matrix3x3* pmat = &mat)
				{
					CreateQuaternionFromMatrixNative((Quaternion*)pquat, (Matrix3x3*)pmat);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its rotational, translational and<br/>
		/// scaling components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiDecomposeMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DecomposeMatrixNative([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Matrix4x4*, Vector3*, Quaternion*, Vector3*, void>)funcTable[34])(mat, scaling, rotation, position);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, void>)funcTable[34])((nint)mat, (nint)scaling, (nint)rotation, (nint)position);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its rotational, translational and<br/>
		/// scaling components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiDecomposeMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DecomposeMatrix([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			DecomposeMatrixNative(mat, scaling, rotation, position);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its rotational, translational and<br/>
		/// scaling components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiDecomposeMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DecomposeMatrix([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				DecomposeMatrixNative((Matrix4x4*)pmat, scaling, rotation, position);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its rotational, translational and<br/>
		/// scaling components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiDecomposeMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DecomposeMatrix([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Vector3* pscaling = &scaling)
			{
				DecomposeMatrixNative(mat, (Vector3*)pscaling, rotation, position);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its rotational, translational and<br/>
		/// scaling components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiDecomposeMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DecomposeMatrix([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* pscaling = &scaling)
				{
					DecomposeMatrixNative((Matrix4x4*)pmat, (Vector3*)pscaling, rotation, position);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its rotational, translational and<br/>
		/// scaling components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiDecomposeMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DecomposeMatrix([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion *")] ref Quaternion rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Quaternion* protation = &rotation)
			{
				DecomposeMatrixNative(mat, scaling, (Quaternion*)protation, position);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its rotational, translational and<br/>
		/// scaling components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiDecomposeMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DecomposeMatrix([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion *")] ref Quaternion rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Quaternion* protation = &rotation)
				{
					DecomposeMatrixNative((Matrix4x4*)pmat, scaling, (Quaternion*)protation, position);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its rotational, translational and<br/>
		/// scaling components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiDecomposeMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DecomposeMatrix([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion *")] ref Quaternion rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Vector3* pscaling = &scaling)
			{
				fixed (Quaternion* protation = &rotation)
				{
					DecomposeMatrixNative(mat, (Vector3*)pscaling, (Quaternion*)protation, position);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its rotational, translational and<br/>
		/// scaling components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiDecomposeMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DecomposeMatrix([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion *")] ref Quaternion rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* pscaling = &scaling)
				{
					fixed (Quaternion* protation = &rotation)
					{
						DecomposeMatrixNative((Matrix4x4*)pmat, (Vector3*)pscaling, (Quaternion*)protation, position);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its rotational, translational and<br/>
		/// scaling components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiDecomposeMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DecomposeMatrix([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Vector3* pposition = &position)
			{
				DecomposeMatrixNative(mat, scaling, rotation, (Vector3*)pposition);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its rotational, translational and<br/>
		/// scaling components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiDecomposeMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DecomposeMatrix([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* pposition = &position)
				{
					DecomposeMatrixNative((Matrix4x4*)pmat, scaling, rotation, (Vector3*)pposition);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its rotational, translational and<br/>
		/// scaling components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiDecomposeMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DecomposeMatrix([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Vector3* pscaling = &scaling)
			{
				fixed (Vector3* pposition = &position)
				{
					DecomposeMatrixNative(mat, (Vector3*)pscaling, rotation, (Vector3*)pposition);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its rotational, translational and<br/>
		/// scaling components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiDecomposeMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DecomposeMatrix([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* pscaling = &scaling)
				{
					fixed (Vector3* pposition = &position)
					{
						DecomposeMatrixNative((Matrix4x4*)pmat, (Vector3*)pscaling, rotation, (Vector3*)pposition);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its rotational, translational and<br/>
		/// scaling components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiDecomposeMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DecomposeMatrix([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion *")] ref Quaternion rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Quaternion* protation = &rotation)
			{
				fixed (Vector3* pposition = &position)
				{
					DecomposeMatrixNative(mat, scaling, (Quaternion*)protation, (Vector3*)pposition);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its rotational, translational and<br/>
		/// scaling components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiDecomposeMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DecomposeMatrix([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion *")] ref Quaternion rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Quaternion* protation = &rotation)
				{
					fixed (Vector3* pposition = &position)
					{
						DecomposeMatrixNative((Matrix4x4*)pmat, scaling, (Quaternion*)protation, (Vector3*)pposition);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its rotational, translational and<br/>
		/// scaling components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiDecomposeMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DecomposeMatrix([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion *")] ref Quaternion rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Vector3* pscaling = &scaling)
			{
				fixed (Quaternion* protation = &rotation)
				{
					fixed (Vector3* pposition = &position)
					{
						DecomposeMatrixNative(mat, (Vector3*)pscaling, (Quaternion*)protation, (Vector3*)pposition);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its rotational, translational and<br/>
		/// scaling components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiDecomposeMatrix")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DecomposeMatrix([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion *")] ref Quaternion rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* pscaling = &scaling)
				{
					fixed (Quaternion* protation = &rotation)
					{
						fixed (Vector3* pposition = &position)
						{
							DecomposeMatrixNative((Matrix4x4*)pmat, (Vector3*)pscaling, (Quaternion*)protation, (Vector3*)pposition);
						}
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Transpose a 4x4 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiTransposeMatrix4")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TransposeMatrix4Native([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Matrix4x4*, void>)funcTable[35])(mat);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[35])((nint)mat);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Transpose a 4x4 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiTransposeMatrix4")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TransposeMatrix4([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat)
		{
			TransposeMatrix4Native(mat);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Transpose a 4x4 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiTransposeMatrix4")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TransposeMatrix4([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 mat)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				TransposeMatrix4Native((Matrix4x4*)pmat);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Transpose a 3x3 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiTransposeMatrix3")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TransposeMatrix3Native([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] Matrix3x3* mat)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Matrix3x3*, void>)funcTable[36])(mat);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[36])((nint)mat);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Transpose a 3x3 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiTransposeMatrix3")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TransposeMatrix3([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] Matrix3x3* mat)
		{
			TransposeMatrix3Native(mat);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Transpose a 3x3 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiTransposeMatrix3")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TransposeMatrix3([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] ref Matrix3x3 mat)
		{
			fixed (Matrix3x3* pmat = &mat)
			{
				TransposeMatrix3Native((Matrix3x3*)pmat);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Transform a vector by a 3x3 matrix<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiTransformVecByMatrix3")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TransformVecByMatrix3Native([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* vec, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] Matrix3x3* mat)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3*, Matrix3x3*, void>)funcTable[37])(vec, mat);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[37])((nint)vec, (nint)mat);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Transform a vector by a 3x3 matrix<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiTransformVecByMatrix3")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TransformVecByMatrix3([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* vec, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] Matrix3x3* mat)
		{
			TransformVecByMatrix3Native(vec, mat);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Transform a vector by a 3x3 matrix<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiTransformVecByMatrix3")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TransformVecByMatrix3([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 vec, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] Matrix3x3* mat)
		{
			fixed (Vector3* pvec = &vec)
			{
				TransformVecByMatrix3Native((Vector3*)pvec, mat);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Transform a vector by a 3x3 matrix<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiTransformVecByMatrix3")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TransformVecByMatrix3([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* vec, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] ref Matrix3x3 mat)
		{
			fixed (Matrix3x3* pmat = &mat)
			{
				TransformVecByMatrix3Native(vec, (Matrix3x3*)pmat);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Transform a vector by a 3x3 matrix<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiTransformVecByMatrix3")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TransformVecByMatrix3([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 vec, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] ref Matrix3x3 mat)
		{
			fixed (Vector3* pvec = &vec)
			{
				fixed (Matrix3x3* pmat = &mat)
				{
					TransformVecByMatrix3Native((Vector3*)pvec, (Matrix3x3*)pmat);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Transform a vector by a 4x4 matrix<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiTransformVecByMatrix4")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TransformVecByMatrix4Native([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* vec, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3*, Matrix4x4*, void>)funcTable[38])(vec, mat);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[38])((nint)vec, (nint)mat);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Transform a vector by a 4x4 matrix<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiTransformVecByMatrix4")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TransformVecByMatrix4([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* vec, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat)
		{
			TransformVecByMatrix4Native(vec, mat);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Transform a vector by a 4x4 matrix<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiTransformVecByMatrix4")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TransformVecByMatrix4([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 vec, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat)
		{
			fixed (Vector3* pvec = &vec)
			{
				TransformVecByMatrix4Native((Vector3*)pvec, mat);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Transform a vector by a 4x4 matrix<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiTransformVecByMatrix4")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TransformVecByMatrix4([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* vec, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				TransformVecByMatrix4Native(vec, (Matrix4x4*)pmat);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Transform a vector by a 4x4 matrix<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiTransformVecByMatrix4")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TransformVecByMatrix4([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 vec, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat)
		{
			fixed (Vector3* pvec = &vec)
			{
				fixed (Matrix4x4* pmat = &mat)
				{
					TransformVecByMatrix4Native((Vector3*)pvec, (Matrix4x4*)pmat);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply two 4x4 matrices.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMultiplyMatrix4")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiplyMatrix4Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* src)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Matrix4x4*, Matrix4x4*, void>)funcTable[39])(dst, src);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[39])((nint)dst, (nint)src);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply two 4x4 matrices.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMultiplyMatrix4")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void MultiplyMatrix4([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* src)
		{
			MultiplyMatrix4Native(dst, src);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply two 4x4 matrices.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMultiplyMatrix4")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void MultiplyMatrix4([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* src)
		{
			fixed (Matrix4x4* pdst = &dst)
			{
				MultiplyMatrix4Native((Matrix4x4*)pdst, src);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply two 4x4 matrices.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMultiplyMatrix4")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void MultiplyMatrix4([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 src)
		{
			fixed (Matrix4x4* psrc = &src)
			{
				MultiplyMatrix4Native(dst, (Matrix4x4*)psrc);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply two 4x4 matrices.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMultiplyMatrix4")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void MultiplyMatrix4([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 src)
		{
			fixed (Matrix4x4* pdst = &dst)
			{
				fixed (Matrix4x4* psrc = &src)
				{
					MultiplyMatrix4Native((Matrix4x4*)pdst, (Matrix4x4*)psrc);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply two 3x3 matrices.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMultiplyMatrix3")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiplyMatrix3Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] Matrix3x3* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] Matrix3x3* src)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Matrix3x3*, Matrix3x3*, void>)funcTable[40])(dst, src);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[40])((nint)dst, (nint)src);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply two 3x3 matrices.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMultiplyMatrix3")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void MultiplyMatrix3([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] Matrix3x3* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] Matrix3x3* src)
		{
			MultiplyMatrix3Native(dst, src);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply two 3x3 matrices.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMultiplyMatrix3")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void MultiplyMatrix3([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] ref Matrix3x3 dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] Matrix3x3* src)
		{
			fixed (Matrix3x3* pdst = &dst)
			{
				MultiplyMatrix3Native((Matrix3x3*)pdst, src);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply two 3x3 matrices.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMultiplyMatrix3")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void MultiplyMatrix3([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] Matrix3x3* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] ref Matrix3x3 src)
		{
			fixed (Matrix3x3* psrc = &src)
			{
				MultiplyMatrix3Native(dst, (Matrix3x3*)psrc);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply two 3x3 matrices.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMultiplyMatrix3")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void MultiplyMatrix3([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] ref Matrix3x3 dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] ref Matrix3x3 src)
		{
			fixed (Matrix3x3* pdst = &dst)
			{
				fixed (Matrix3x3* psrc = &src)
				{
					MultiplyMatrix3Native((Matrix3x3*)pdst, (Matrix3x3*)psrc);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 3x3 identity matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiIdentityMatrix3")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IdentityMatrix3Native([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] Matrix3x3* mat)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Matrix3x3*, void>)funcTable[41])(mat);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[41])((nint)mat);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 3x3 identity matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiIdentityMatrix3")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void IdentityMatrix3([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] Matrix3x3* mat)
		{
			IdentityMatrix3Native(mat);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 3x3 identity matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiIdentityMatrix3")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void IdentityMatrix3([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] ref Matrix3x3 mat)
		{
			fixed (Matrix3x3* pmat = &mat)
			{
				IdentityMatrix3Native((Matrix3x3*)pmat);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 4x4 identity matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiIdentityMatrix4")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IdentityMatrix4Native([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Matrix4x4*, void>)funcTable[42])(mat);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[42])((nint)mat);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 4x4 identity matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiIdentityMatrix4")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void IdentityMatrix4([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat)
		{
			IdentityMatrix4Native(mat);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 4x4 identity matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiIdentityMatrix4")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void IdentityMatrix4([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 mat)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				IdentityMatrix4Native((Matrix4x4*)pmat);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns the number of import file formats available in the current Assimp build.<br/>
		/// Use aiGetImportFormatDescription() to retrieve infos of a specific import format.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetImportFormatCount")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint GetImportFormatCountNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<nuint>)funcTable[43])();
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nuint>)funcTable[43])();
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns the number of import file formats available in the current Assimp build.<br/>
		/// Use aiGetImportFormatDescription() to retrieve infos of a specific import format.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetImportFormatCount")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint GetImportFormatCount()
		{
			nuint ret = GetImportFormatCountNative();
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns a description of the nth import file format. Use #aiGetImportFormatCount()<br/>
		/// to learn how many import formats are supported.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetImportFormatDescription")]
		[return: NativeName(NativeNameType.Type, "aiImporterDesc const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static AiImporterDesc* GetImportFormatDescriptionNative([NativeName(NativeNameType.Param, "pIndex")] [NativeName(NativeNameType.Type, "size_t")] nuint pIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<nuint, AiImporterDesc*>)funcTable[44])(pIndex);
			#else
			return (AiImporterDesc*)((delegate* unmanaged[Cdecl]<nuint, nint>)funcTable[44])(pIndex);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns a description of the nth import file format. Use #aiGetImportFormatCount()<br/>
		/// to learn how many import formats are supported.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetImportFormatDescription")]
		[return: NativeName(NativeNameType.Type, "aiImporterDesc const *")]
		public static AiImporterDesc* GetImportFormatDescription([NativeName(NativeNameType.Param, "pIndex")] [NativeName(NativeNameType.Type, "size_t")] nuint pIndex)
		{
			AiImporterDesc* ret = GetImportFormatDescriptionNative(pIndex);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 2D vectors are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2AreEqual")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int Vector2AreEqualNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2*, Vector2*, int>)funcTable[45])(a, b);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[45])((nint)a, (nint)b);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 2D vectors are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2AreEqual")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Vector2AreEqual([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* b)
		{
			int ret = Vector2AreEqualNative(a, b);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 2D vectors are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2AreEqual")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Vector2AreEqual([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector2D const *")] ref Vector2 a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* b)
		{
			fixed (Vector2* pa = &a)
			{
				int ret = Vector2AreEqualNative((Vector2*)pa, b);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 2D vectors are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2AreEqual")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Vector2AreEqual([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector2D const *")] ref Vector2 b)
		{
			fixed (Vector2* pb = &b)
			{
				int ret = Vector2AreEqualNative(a, (Vector2*)pb);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 2D vectors are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2AreEqual")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Vector2AreEqual([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector2D const *")] ref Vector2 a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector2D const *")] ref Vector2 b)
		{
			fixed (Vector2* pa = &a)
			{
				fixed (Vector2* pb = &b)
				{
					int ret = Vector2AreEqualNative((Vector2*)pa, (Vector2*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 2D vectors are equal using epsilon.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2AreEqualEpsilon")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int Vector2AreEqualEpsilonNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* b, [NativeName(NativeNameType.Param, "epsilon")] [NativeName(NativeNameType.Type, "float const")] float epsilon)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2*, Vector2*, float, int>)funcTable[46])(a, b, epsilon);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, float, int>)funcTable[46])((nint)a, (nint)b, epsilon);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 2D vectors are equal using epsilon.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2AreEqualEpsilon")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Vector2AreEqualEpsilon([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* b, [NativeName(NativeNameType.Param, "epsilon")] [NativeName(NativeNameType.Type, "float const")] float epsilon)
		{
			int ret = Vector2AreEqualEpsilonNative(a, b, epsilon);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 2D vectors are equal using epsilon.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2AreEqualEpsilon")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Vector2AreEqualEpsilon([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector2D const *")] ref Vector2 a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* b, [NativeName(NativeNameType.Param, "epsilon")] [NativeName(NativeNameType.Type, "float const")] float epsilon)
		{
			fixed (Vector2* pa = &a)
			{
				int ret = Vector2AreEqualEpsilonNative((Vector2*)pa, b, epsilon);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 2D vectors are equal using epsilon.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2AreEqualEpsilon")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Vector2AreEqualEpsilon([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector2D const *")] ref Vector2 b, [NativeName(NativeNameType.Param, "epsilon")] [NativeName(NativeNameType.Type, "float const")] float epsilon)
		{
			fixed (Vector2* pb = &b)
			{
				int ret = Vector2AreEqualEpsilonNative(a, (Vector2*)pb, epsilon);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 2D vectors are equal using epsilon.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2AreEqualEpsilon")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Vector2AreEqualEpsilon([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector2D const *")] ref Vector2 a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector2D const *")] ref Vector2 b, [NativeName(NativeNameType.Param, "epsilon")] [NativeName(NativeNameType.Type, "float const")] float epsilon)
		{
			fixed (Vector2* pa = &a)
			{
				fixed (Vector2* pb = &b)
				{
					int ret = Vector2AreEqualEpsilonNative((Vector2*)pa, (Vector2*)pb, epsilon);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Add 2D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2Add")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vector2AddNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector2D *")] Vector2* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* src)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, Vector2*, void>)funcTable[47])(dst, src);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[47])((nint)dst, (nint)src);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Add 2D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2Add")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector2Add([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector2D *")] Vector2* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* src)
		{
			Vector2AddNative(dst, src);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Add 2D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2Add")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector2Add([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector2D *")] ref Vector2 dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* src)
		{
			fixed (Vector2* pdst = &dst)
			{
				Vector2AddNative((Vector2*)pdst, src);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Add 2D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2Add")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector2Add([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector2D *")] Vector2* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiVector2D const *")] ref Vector2 src)
		{
			fixed (Vector2* psrc = &src)
			{
				Vector2AddNative(dst, (Vector2*)psrc);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Add 2D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2Add")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector2Add([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector2D *")] ref Vector2 dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiVector2D const *")] ref Vector2 src)
		{
			fixed (Vector2* pdst = &dst)
			{
				fixed (Vector2* psrc = &src)
				{
					Vector2AddNative((Vector2*)pdst, (Vector2*)psrc);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Subtract 2D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2Subtract")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vector2SubtractNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector2D *")] Vector2* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* src)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, Vector2*, void>)funcTable[48])(dst, src);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[48])((nint)dst, (nint)src);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Subtract 2D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2Subtract")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector2Subtract([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector2D *")] Vector2* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* src)
		{
			Vector2SubtractNative(dst, src);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Subtract 2D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2Subtract")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector2Subtract([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector2D *")] ref Vector2 dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* src)
		{
			fixed (Vector2* pdst = &dst)
			{
				Vector2SubtractNative((Vector2*)pdst, src);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Subtract 2D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2Subtract")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector2Subtract([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector2D *")] Vector2* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiVector2D const *")] ref Vector2 src)
		{
			fixed (Vector2* psrc = &src)
			{
				Vector2SubtractNative(dst, (Vector2*)psrc);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Subtract 2D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2Subtract")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector2Subtract([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector2D *")] ref Vector2 dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiVector2D const *")] ref Vector2 src)
		{
			fixed (Vector2* pdst = &dst)
			{
				fixed (Vector2* psrc = &src)
				{
					Vector2SubtractNative((Vector2*)pdst, (Vector2*)psrc);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply a 2D vector by a scalar.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2Scale")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vector2ScaleNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector2D *")] Vector2* dst, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "float const")] float s)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, float, void>)funcTable[49])(dst, s);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, void>)funcTable[49])((nint)dst, s);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply a 2D vector by a scalar.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2Scale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector2Scale([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector2D *")] Vector2* dst, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "float const")] float s)
		{
			Vector2ScaleNative(dst, s);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply a 2D vector by a scalar.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2Scale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector2Scale([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector2D *")] ref Vector2 dst, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "float const")] float s)
		{
			fixed (Vector2* pdst = &dst)
			{
				Vector2ScaleNative((Vector2*)pdst, s);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply each component of a 2D vector with<br/>
		/// the components of another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2SymMul")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vector2SymMulNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector2D *")] Vector2* dst, [NativeName(NativeNameType.Param, "other")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* other)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, Vector2*, void>)funcTable[50])(dst, other);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[50])((nint)dst, (nint)other);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply each component of a 2D vector with<br/>
		/// the components of another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2SymMul")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector2SymMul([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector2D *")] Vector2* dst, [NativeName(NativeNameType.Param, "other")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* other)
		{
			Vector2SymMulNative(dst, other);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply each component of a 2D vector with<br/>
		/// the components of another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2SymMul")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector2SymMul([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector2D *")] ref Vector2 dst, [NativeName(NativeNameType.Param, "other")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* other)
		{
			fixed (Vector2* pdst = &dst)
			{
				Vector2SymMulNative((Vector2*)pdst, other);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply each component of a 2D vector with<br/>
		/// the components of another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2SymMul")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector2SymMul([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector2D *")] Vector2* dst, [NativeName(NativeNameType.Param, "other")] [NativeName(NativeNameType.Type, "aiVector2D const *")] ref Vector2 other)
		{
			fixed (Vector2* pother = &other)
			{
				Vector2SymMulNative(dst, (Vector2*)pother);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply each component of a 2D vector with<br/>
		/// the components of another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2SymMul")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector2SymMul([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector2D *")] ref Vector2 dst, [NativeName(NativeNameType.Param, "other")] [NativeName(NativeNameType.Type, "aiVector2D const *")] ref Vector2 other)
		{
			fixed (Vector2* pdst = &dst)
			{
				fixed (Vector2* pother = &other)
				{
					Vector2SymMulNative((Vector2*)pdst, (Vector2*)pother);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Divide a 2D vector by a scalar.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2DivideByScalar")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vector2DivideByScalarNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector2D *")] Vector2* dst, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "float const")] float s)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, float, void>)funcTable[51])(dst, s);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, void>)funcTable[51])((nint)dst, s);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Divide a 2D vector by a scalar.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2DivideByScalar")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector2DivideByScalar([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector2D *")] Vector2* dst, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "float const")] float s)
		{
			Vector2DivideByScalarNative(dst, s);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Divide a 2D vector by a scalar.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2DivideByScalar")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector2DivideByScalar([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector2D *")] ref Vector2 dst, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "float const")] float s)
		{
			fixed (Vector2* pdst = &dst)
			{
				Vector2DivideByScalarNative((Vector2*)pdst, s);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Divide each component of a 2D vector by<br/>
		/// the components of another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2DivideByVector")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vector2DivideByVectorNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector2D *")] Vector2* dst, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector2D *")] Vector2* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, Vector2*, void>)funcTable[52])(dst, v);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[52])((nint)dst, (nint)v);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Divide each component of a 2D vector by<br/>
		/// the components of another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2DivideByVector")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector2DivideByVector([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector2D *")] Vector2* dst, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector2D *")] Vector2* v)
		{
			Vector2DivideByVectorNative(dst, v);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Divide each component of a 2D vector by<br/>
		/// the components of another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2DivideByVector")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector2DivideByVector([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector2D *")] ref Vector2 dst, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector2D *")] Vector2* v)
		{
			fixed (Vector2* pdst = &dst)
			{
				Vector2DivideByVectorNative((Vector2*)pdst, v);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Divide each component of a 2D vector by<br/>
		/// the components of another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2DivideByVector")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector2DivideByVector([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector2D *")] Vector2* dst, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector2D *")] ref Vector2 v)
		{
			fixed (Vector2* pv = &v)
			{
				Vector2DivideByVectorNative(dst, (Vector2*)pv);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Divide each component of a 2D vector by<br/>
		/// the components of another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2DivideByVector")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector2DivideByVector([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector2D *")] ref Vector2 dst, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector2D *")] ref Vector2 v)
		{
			fixed (Vector2* pdst = &dst)
			{
				fixed (Vector2* pv = &v)
				{
					Vector2DivideByVectorNative((Vector2*)pdst, (Vector2*)pv);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the length of a 2D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2Length")]
		[return: NativeName(NativeNameType.Type, "ai_real")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double Vector2LengthNative([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2*, double>)funcTable[53])(v);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, double>)funcTable[53])((nint)v);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the length of a 2D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2Length")]
		[return: NativeName(NativeNameType.Type, "ai_real")]
		public static double Vector2Length([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* v)
		{
			double ret = Vector2LengthNative(v);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the length of a 2D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2Length")]
		[return: NativeName(NativeNameType.Type, "ai_real")]
		public static double Vector2Length([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector2D const *")] ref Vector2 v)
		{
			fixed (Vector2* pv = &v)
			{
				double ret = Vector2LengthNative((Vector2*)pv);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the squared length of a 2D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2SquareLength")]
		[return: NativeName(NativeNameType.Type, "ai_real")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double Vector2SquareLengthNative([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2*, double>)funcTable[54])(v);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, double>)funcTable[54])((nint)v);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the squared length of a 2D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2SquareLength")]
		[return: NativeName(NativeNameType.Type, "ai_real")]
		public static double Vector2SquareLength([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* v)
		{
			double ret = Vector2SquareLengthNative(v);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the squared length of a 2D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2SquareLength")]
		[return: NativeName(NativeNameType.Type, "ai_real")]
		public static double Vector2SquareLength([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector2D const *")] ref Vector2 v)
		{
			fixed (Vector2* pv = &v)
			{
				double ret = Vector2SquareLengthNative((Vector2*)pv);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Negate a 2D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2Negate")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vector2NegateNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector2D *")] Vector2* dst)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)funcTable[55])(dst);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[55])((nint)dst);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Negate a 2D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2Negate")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector2Negate([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector2D *")] Vector2* dst)
		{
			Vector2NegateNative(dst);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Negate a 2D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2Negate")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector2Negate([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector2D *")] ref Vector2 dst)
		{
			fixed (Vector2* pdst = &dst)
			{
				Vector2NegateNative((Vector2*)pdst);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the dot product of 2D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2DotProduct")]
		[return: NativeName(NativeNameType.Type, "ai_real")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double Vector2DotProductNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2*, Vector2*, double>)funcTable[56])(a, b);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, nint, double>)funcTable[56])((nint)a, (nint)b);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the dot product of 2D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2DotProduct")]
		[return: NativeName(NativeNameType.Type, "ai_real")]
		public static double Vector2DotProduct([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* b)
		{
			double ret = Vector2DotProductNative(a, b);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the dot product of 2D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2DotProduct")]
		[return: NativeName(NativeNameType.Type, "ai_real")]
		public static double Vector2DotProduct([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector2D const *")] ref Vector2 a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* b)
		{
			fixed (Vector2* pa = &a)
			{
				double ret = Vector2DotProductNative((Vector2*)pa, b);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the dot product of 2D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2DotProduct")]
		[return: NativeName(NativeNameType.Type, "ai_real")]
		public static double Vector2DotProduct([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector2D const *")] ref Vector2 b)
		{
			fixed (Vector2* pb = &b)
			{
				double ret = Vector2DotProductNative(a, (Vector2*)pb);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the dot product of 2D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2DotProduct")]
		[return: NativeName(NativeNameType.Type, "ai_real")]
		public static double Vector2DotProduct([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector2D const *")] ref Vector2 a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector2D const *")] ref Vector2 b)
		{
			fixed (Vector2* pa = &a)
			{
				fixed (Vector2* pb = &b)
				{
					double ret = Vector2DotProductNative((Vector2*)pa, (Vector2*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Normalize a 2D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2Normalize")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vector2NormalizeNative([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector2D *")] Vector2* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)funcTable[57])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[57])((nint)v);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Normalize a 2D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2Normalize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector2Normalize([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector2D *")] Vector2* v)
		{
			Vector2NormalizeNative(v);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Normalize a 2D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector2Normalize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector2Normalize([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector2D *")] ref Vector2 v)
		{
			fixed (Vector2* pv = &v)
			{
				Vector2NormalizeNative((Vector2*)pv);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 3D vectors are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3AreEqual")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int Vector3AreEqualNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector3*, Vector3*, int>)funcTable[58])(a, b);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[58])((nint)a, (nint)b);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 3D vectors are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3AreEqual")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Vector3AreEqual([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* b)
		{
			int ret = Vector3AreEqualNative(a, b);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 3D vectors are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3AreEqual")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Vector3AreEqual([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* b)
		{
			fixed (Vector3* pa = &a)
			{
				int ret = Vector3AreEqualNative((Vector3*)pa, b);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 3D vectors are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3AreEqual")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Vector3AreEqual([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 b)
		{
			fixed (Vector3* pb = &b)
			{
				int ret = Vector3AreEqualNative(a, (Vector3*)pb);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 3D vectors are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3AreEqual")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Vector3AreEqual([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 b)
		{
			fixed (Vector3* pa = &a)
			{
				fixed (Vector3* pb = &b)
				{
					int ret = Vector3AreEqualNative((Vector3*)pa, (Vector3*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 3D vectors are equal using epsilon.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3AreEqualEpsilon")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int Vector3AreEqualEpsilonNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* b, [NativeName(NativeNameType.Param, "epsilon")] [NativeName(NativeNameType.Type, "float const")] float epsilon)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector3*, Vector3*, float, int>)funcTable[59])(a, b, epsilon);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, float, int>)funcTable[59])((nint)a, (nint)b, epsilon);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 3D vectors are equal using epsilon.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3AreEqualEpsilon")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Vector3AreEqualEpsilon([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* b, [NativeName(NativeNameType.Param, "epsilon")] [NativeName(NativeNameType.Type, "float const")] float epsilon)
		{
			int ret = Vector3AreEqualEpsilonNative(a, b, epsilon);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 3D vectors are equal using epsilon.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3AreEqualEpsilon")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Vector3AreEqualEpsilon([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* b, [NativeName(NativeNameType.Param, "epsilon")] [NativeName(NativeNameType.Type, "float const")] float epsilon)
		{
			fixed (Vector3* pa = &a)
			{
				int ret = Vector3AreEqualEpsilonNative((Vector3*)pa, b, epsilon);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 3D vectors are equal using epsilon.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3AreEqualEpsilon")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Vector3AreEqualEpsilon([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 b, [NativeName(NativeNameType.Param, "epsilon")] [NativeName(NativeNameType.Type, "float const")] float epsilon)
		{
			fixed (Vector3* pb = &b)
			{
				int ret = Vector3AreEqualEpsilonNative(a, (Vector3*)pb, epsilon);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 3D vectors are equal using epsilon.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3AreEqualEpsilon")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Vector3AreEqualEpsilon([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 b, [NativeName(NativeNameType.Param, "epsilon")] [NativeName(NativeNameType.Type, "float const")] float epsilon)
		{
			fixed (Vector3* pa = &a)
			{
				fixed (Vector3* pb = &b)
				{
					int ret = Vector3AreEqualEpsilonNative((Vector3*)pa, (Vector3*)pb, epsilon);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if vector <br/>
		/// is less than vector <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3LessThan")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int Vector3LessThanNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector3*, Vector3*, int>)funcTable[60])(a, b);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[60])((nint)a, (nint)b);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if vector <br/>
		/// is less than vector <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3LessThan")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Vector3LessThan([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* b)
		{
			int ret = Vector3LessThanNative(a, b);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if vector <br/>
		/// is less than vector <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3LessThan")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Vector3LessThan([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* b)
		{
			fixed (Vector3* pa = &a)
			{
				int ret = Vector3LessThanNative((Vector3*)pa, b);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if vector <br/>
		/// is less than vector <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3LessThan")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Vector3LessThan([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 b)
		{
			fixed (Vector3* pb = &b)
			{
				int ret = Vector3LessThanNative(a, (Vector3*)pb);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if vector <br/>
		/// is less than vector <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3LessThan")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Vector3LessThan([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 b)
		{
			fixed (Vector3* pa = &a)
			{
				fixed (Vector3* pb = &b)
				{
					int ret = Vector3LessThanNative((Vector3*)pa, (Vector3*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Add 3D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3Add")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vector3AddNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* src)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3*, Vector3*, void>)funcTable[61])(dst, src);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[61])((nint)dst, (nint)src);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Add 3D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3Add")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3Add([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* src)
		{
			Vector3AddNative(dst, src);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Add 3D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3Add")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3Add([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* src)
		{
			fixed (Vector3* pdst = &dst)
			{
				Vector3AddNative((Vector3*)pdst, src);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Add 3D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3Add")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3Add([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 src)
		{
			fixed (Vector3* psrc = &src)
			{
				Vector3AddNative(dst, (Vector3*)psrc);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Add 3D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3Add")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3Add([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 src)
		{
			fixed (Vector3* pdst = &dst)
			{
				fixed (Vector3* psrc = &src)
				{
					Vector3AddNative((Vector3*)pdst, (Vector3*)psrc);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Subtract 3D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3Subtract")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vector3SubtractNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* src)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3*, Vector3*, void>)funcTable[62])(dst, src);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[62])((nint)dst, (nint)src);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Subtract 3D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3Subtract")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3Subtract([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* src)
		{
			Vector3SubtractNative(dst, src);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Subtract 3D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3Subtract")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3Subtract([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* src)
		{
			fixed (Vector3* pdst = &dst)
			{
				Vector3SubtractNative((Vector3*)pdst, src);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Subtract 3D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3Subtract")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3Subtract([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 src)
		{
			fixed (Vector3* psrc = &src)
			{
				Vector3SubtractNative(dst, (Vector3*)psrc);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Subtract 3D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3Subtract")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3Subtract([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 src)
		{
			fixed (Vector3* pdst = &dst)
			{
				fixed (Vector3* psrc = &src)
				{
					Vector3SubtractNative((Vector3*)pdst, (Vector3*)psrc);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply a 3D vector by a scalar.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3Scale")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vector3ScaleNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* dst, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "float const")] float s)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3*, float, void>)funcTable[63])(dst, s);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, void>)funcTable[63])((nint)dst, s);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply a 3D vector by a scalar.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3Scale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3Scale([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* dst, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "float const")] float s)
		{
			Vector3ScaleNative(dst, s);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply a 3D vector by a scalar.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3Scale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3Scale([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 dst, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "float const")] float s)
		{
			fixed (Vector3* pdst = &dst)
			{
				Vector3ScaleNative((Vector3*)pdst, s);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply each component of a 3D vector with<br/>
		/// the components of another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3SymMul")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vector3SymMulNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* dst, [NativeName(NativeNameType.Param, "other")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* other)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3*, Vector3*, void>)funcTable[64])(dst, other);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[64])((nint)dst, (nint)other);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply each component of a 3D vector with<br/>
		/// the components of another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3SymMul")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3SymMul([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* dst, [NativeName(NativeNameType.Param, "other")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* other)
		{
			Vector3SymMulNative(dst, other);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply each component of a 3D vector with<br/>
		/// the components of another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3SymMul")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3SymMul([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 dst, [NativeName(NativeNameType.Param, "other")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* other)
		{
			fixed (Vector3* pdst = &dst)
			{
				Vector3SymMulNative((Vector3*)pdst, other);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply each component of a 3D vector with<br/>
		/// the components of another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3SymMul")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3SymMul([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* dst, [NativeName(NativeNameType.Param, "other")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 other)
		{
			fixed (Vector3* pother = &other)
			{
				Vector3SymMulNative(dst, (Vector3*)pother);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply each component of a 3D vector with<br/>
		/// the components of another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3SymMul")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3SymMul([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 dst, [NativeName(NativeNameType.Param, "other")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 other)
		{
			fixed (Vector3* pdst = &dst)
			{
				fixed (Vector3* pother = &other)
				{
					Vector3SymMulNative((Vector3*)pdst, (Vector3*)pother);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Divide a 3D vector by a scalar.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3DivideByScalar")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vector3DivideByScalarNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* dst, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "float const")] float s)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3*, float, void>)funcTable[65])(dst, s);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, void>)funcTable[65])((nint)dst, s);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Divide a 3D vector by a scalar.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3DivideByScalar")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3DivideByScalar([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* dst, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "float const")] float s)
		{
			Vector3DivideByScalarNative(dst, s);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Divide a 3D vector by a scalar.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3DivideByScalar")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3DivideByScalar([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 dst, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "float const")] float s)
		{
			fixed (Vector3* pdst = &dst)
			{
				Vector3DivideByScalarNative((Vector3*)pdst, s);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Divide each component of a 3D vector by<br/>
		/// the components of another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3DivideByVector")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vector3DivideByVectorNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* dst, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3*, Vector3*, void>)funcTable[66])(dst, v);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[66])((nint)dst, (nint)v);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Divide each component of a 3D vector by<br/>
		/// the components of another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3DivideByVector")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3DivideByVector([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* dst, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* v)
		{
			Vector3DivideByVectorNative(dst, v);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Divide each component of a 3D vector by<br/>
		/// the components of another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3DivideByVector")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3DivideByVector([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 dst, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* v)
		{
			fixed (Vector3* pdst = &dst)
			{
				Vector3DivideByVectorNative((Vector3*)pdst, v);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Divide each component of a 3D vector by<br/>
		/// the components of another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3DivideByVector")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3DivideByVector([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* dst, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 v)
		{
			fixed (Vector3* pv = &v)
			{
				Vector3DivideByVectorNative(dst, (Vector3*)pv);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Divide each component of a 3D vector by<br/>
		/// the components of another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3DivideByVector")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3DivideByVector([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 dst, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 v)
		{
			fixed (Vector3* pdst = &dst)
			{
				fixed (Vector3* pv = &v)
				{
					Vector3DivideByVectorNative((Vector3*)pdst, (Vector3*)pv);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the length of a 3D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3Length")]
		[return: NativeName(NativeNameType.Type, "ai_real")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double Vector3LengthNative([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector3*, double>)funcTable[67])(v);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, double>)funcTable[67])((nint)v);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the length of a 3D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3Length")]
		[return: NativeName(NativeNameType.Type, "ai_real")]
		public static double Vector3Length([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* v)
		{
			double ret = Vector3LengthNative(v);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the length of a 3D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3Length")]
		[return: NativeName(NativeNameType.Type, "ai_real")]
		public static double Vector3Length([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 v)
		{
			fixed (Vector3* pv = &v)
			{
				double ret = Vector3LengthNative((Vector3*)pv);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the squared length of a 3D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3SquareLength")]
		[return: NativeName(NativeNameType.Type, "ai_real")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double Vector3SquareLengthNative([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector3*, double>)funcTable[68])(v);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, double>)funcTable[68])((nint)v);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the squared length of a 3D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3SquareLength")]
		[return: NativeName(NativeNameType.Type, "ai_real")]
		public static double Vector3SquareLength([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* v)
		{
			double ret = Vector3SquareLengthNative(v);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the squared length of a 3D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3SquareLength")]
		[return: NativeName(NativeNameType.Type, "ai_real")]
		public static double Vector3SquareLength([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 v)
		{
			fixed (Vector3* pv = &v)
			{
				double ret = Vector3SquareLengthNative((Vector3*)pv);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Negate a 3D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3Negate")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vector3NegateNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* dst)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3*, void>)funcTable[69])(dst);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[69])((nint)dst);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Negate a 3D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3Negate")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3Negate([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* dst)
		{
			Vector3NegateNative(dst);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Negate a 3D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3Negate")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3Negate([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 dst)
		{
			fixed (Vector3* pdst = &dst)
			{
				Vector3NegateNative((Vector3*)pdst);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the dot product of 3D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3DotProduct")]
		[return: NativeName(NativeNameType.Type, "ai_real")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double Vector3DotProductNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector3*, Vector3*, double>)funcTable[70])(a, b);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, nint, double>)funcTable[70])((nint)a, (nint)b);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the dot product of 3D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3DotProduct")]
		[return: NativeName(NativeNameType.Type, "ai_real")]
		public static double Vector3DotProduct([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* b)
		{
			double ret = Vector3DotProductNative(a, b);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the dot product of 3D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3DotProduct")]
		[return: NativeName(NativeNameType.Type, "ai_real")]
		public static double Vector3DotProduct([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* b)
		{
			fixed (Vector3* pa = &a)
			{
				double ret = Vector3DotProductNative((Vector3*)pa, b);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the dot product of 3D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3DotProduct")]
		[return: NativeName(NativeNameType.Type, "ai_real")]
		public static double Vector3DotProduct([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 b)
		{
			fixed (Vector3* pb = &b)
			{
				double ret = Vector3DotProductNative(a, (Vector3*)pb);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the dot product of 3D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3DotProduct")]
		[return: NativeName(NativeNameType.Type, "ai_real")]
		public static double Vector3DotProduct([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 b)
		{
			fixed (Vector3* pa = &a)
			{
				fixed (Vector3* pb = &b)
				{
					double ret = Vector3DotProductNative((Vector3*)pa, (Vector3*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get cross product of 3D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3CrossProduct")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vector3CrossProductNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* dst, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* b)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3*, Vector3*, Vector3*, void>)funcTable[71])(dst, a, b);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[71])((nint)dst, (nint)a, (nint)b);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get cross product of 3D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3CrossProduct")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3CrossProduct([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* dst, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* b)
		{
			Vector3CrossProductNative(dst, a, b);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get cross product of 3D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3CrossProduct")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3CrossProduct([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 dst, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* b)
		{
			fixed (Vector3* pdst = &dst)
			{
				Vector3CrossProductNative((Vector3*)pdst, a, b);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get cross product of 3D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3CrossProduct")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3CrossProduct([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* dst, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* b)
		{
			fixed (Vector3* pa = &a)
			{
				Vector3CrossProductNative(dst, (Vector3*)pa, b);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get cross product of 3D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3CrossProduct")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3CrossProduct([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 dst, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* b)
		{
			fixed (Vector3* pdst = &dst)
			{
				fixed (Vector3* pa = &a)
				{
					Vector3CrossProductNative((Vector3*)pdst, (Vector3*)pa, b);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get cross product of 3D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3CrossProduct")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3CrossProduct([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* dst, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 b)
		{
			fixed (Vector3* pb = &b)
			{
				Vector3CrossProductNative(dst, a, (Vector3*)pb);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get cross product of 3D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3CrossProduct")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3CrossProduct([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 dst, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 b)
		{
			fixed (Vector3* pdst = &dst)
			{
				fixed (Vector3* pb = &b)
				{
					Vector3CrossProductNative((Vector3*)pdst, a, (Vector3*)pb);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get cross product of 3D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3CrossProduct")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3CrossProduct([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* dst, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 b)
		{
			fixed (Vector3* pa = &a)
			{
				fixed (Vector3* pb = &b)
				{
					Vector3CrossProductNative(dst, (Vector3*)pa, (Vector3*)pb);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get cross product of 3D vectors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3CrossProduct")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3CrossProduct([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 dst, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 b)
		{
			fixed (Vector3* pdst = &dst)
			{
				fixed (Vector3* pa = &a)
				{
					fixed (Vector3* pb = &b)
					{
						Vector3CrossProductNative((Vector3*)pdst, (Vector3*)pa, (Vector3*)pb);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Normalize a 3D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3Normalize")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vector3NormalizeNative([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3*, void>)funcTable[72])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[72])((nint)v);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Normalize a 3D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3Normalize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3Normalize([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* v)
		{
			Vector3NormalizeNative(v);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Normalize a 3D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3Normalize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3Normalize([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 v)
		{
			fixed (Vector3* pv = &v)
			{
				Vector3NormalizeNative((Vector3*)pv);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check for division by zero and normalize a 3D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3NormalizeSafe")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vector3NormalizeSafeNative([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3*, void>)funcTable[73])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[73])((nint)v);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check for division by zero and normalize a 3D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3NormalizeSafe")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3NormalizeSafe([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* v)
		{
			Vector3NormalizeSafeNative(v);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check for division by zero and normalize a 3D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3NormalizeSafe")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3NormalizeSafe([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 v)
		{
			fixed (Vector3* pv = &v)
			{
				Vector3NormalizeSafeNative((Vector3*)pv);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Rotate a 3D vector by a quaternion.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3RotateByQuaternion")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vector3RotateByQuaternionNative([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* v, [NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* q)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector3*, Quaternion*, void>)funcTable[74])(v, q);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[74])((nint)v, (nint)q);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Rotate a 3D vector by a quaternion.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3RotateByQuaternion")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3RotateByQuaternion([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* v, [NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* q)
		{
			Vector3RotateByQuaternionNative(v, q);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Rotate a 3D vector by a quaternion.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3RotateByQuaternion")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3RotateByQuaternion([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 v, [NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* q)
		{
			fixed (Vector3* pv = &v)
			{
				Vector3RotateByQuaternionNative((Vector3*)pv, q);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Rotate a 3D vector by a quaternion.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3RotateByQuaternion")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3RotateByQuaternion([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* v, [NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion q)
		{
			fixed (Quaternion* pq = &q)
			{
				Vector3RotateByQuaternionNative(v, (Quaternion*)pq);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Rotate a 3D vector by a quaternion.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiVector3RotateByQuaternion")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Vector3RotateByQuaternion([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 v, [NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion q)
		{
			fixed (Vector3* pv = &v)
			{
				fixed (Quaternion* pq = &q)
				{
					Vector3RotateByQuaternionNative((Vector3*)pv, (Quaternion*)pq);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 3x3 matrix from a 4x4 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3FromMatrix4")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Matrix3FromMatrix4Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] Matrix3x3* dst, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Matrix3x3*, Matrix4x4*, void>)funcTable[75])(dst, mat);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[75])((nint)dst, (nint)mat);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 3x3 matrix from a 4x4 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3FromMatrix4")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix3FromMatrix4([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] Matrix3x3* dst, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat)
		{
			Matrix3FromMatrix4Native(dst, mat);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 3x3 matrix from a 4x4 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3FromMatrix4")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix3FromMatrix4([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] ref Matrix3x3 dst, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat)
		{
			fixed (Matrix3x3* pdst = &dst)
			{
				Matrix3FromMatrix4Native((Matrix3x3*)pdst, mat);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 3x3 matrix from a 4x4 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3FromMatrix4")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix3FromMatrix4([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] Matrix3x3* dst, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				Matrix3FromMatrix4Native(dst, (Matrix4x4*)pmat);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 3x3 matrix from a 4x4 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3FromMatrix4")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix3FromMatrix4([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] ref Matrix3x3 dst, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat)
		{
			fixed (Matrix3x3* pdst = &dst)
			{
				fixed (Matrix4x4* pmat = &mat)
				{
					Matrix3FromMatrix4Native((Matrix3x3*)pdst, (Matrix4x4*)pmat);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 3x3 matrix from a quaternion.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3FromQuaternion")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Matrix3FromQuaternionNative([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] Matrix3x3* mat, [NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* q)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Matrix3x3*, Quaternion*, void>)funcTable[76])(mat, q);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[76])((nint)mat, (nint)q);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 3x3 matrix from a quaternion.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3FromQuaternion")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix3FromQuaternion([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] Matrix3x3* mat, [NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* q)
		{
			Matrix3FromQuaternionNative(mat, q);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 3x3 matrix from a quaternion.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3FromQuaternion")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix3FromQuaternion([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] ref Matrix3x3 mat, [NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* q)
		{
			fixed (Matrix3x3* pmat = &mat)
			{
				Matrix3FromQuaternionNative((Matrix3x3*)pmat, q);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 3x3 matrix from a quaternion.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3FromQuaternion")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix3FromQuaternion([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] Matrix3x3* mat, [NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion q)
		{
			fixed (Quaternion* pq = &q)
			{
				Matrix3FromQuaternionNative(mat, (Quaternion*)pq);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 3x3 matrix from a quaternion.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3FromQuaternion")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix3FromQuaternion([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] ref Matrix3x3 mat, [NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion q)
		{
			fixed (Matrix3x3* pmat = &mat)
			{
				fixed (Quaternion* pq = &q)
				{
					Matrix3FromQuaternionNative((Matrix3x3*)pmat, (Quaternion*)pq);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 3x3 matrices are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3AreEqual")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int Matrix3AreEqualNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] Matrix3x3* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] Matrix3x3* b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Matrix3x3*, Matrix3x3*, int>)funcTable[77])(a, b);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[77])((nint)a, (nint)b);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 3x3 matrices are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3AreEqual")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Matrix3AreEqual([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] Matrix3x3* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] Matrix3x3* b)
		{
			int ret = Matrix3AreEqualNative(a, b);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 3x3 matrices are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3AreEqual")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Matrix3AreEqual([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] ref Matrix3x3 a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] Matrix3x3* b)
		{
			fixed (Matrix3x3* pa = &a)
			{
				int ret = Matrix3AreEqualNative((Matrix3x3*)pa, b);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 3x3 matrices are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3AreEqual")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Matrix3AreEqual([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] Matrix3x3* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] ref Matrix3x3 b)
		{
			fixed (Matrix3x3* pb = &b)
			{
				int ret = Matrix3AreEqualNative(a, (Matrix3x3*)pb);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 3x3 matrices are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3AreEqual")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Matrix3AreEqual([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] ref Matrix3x3 a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] ref Matrix3x3 b)
		{
			fixed (Matrix3x3* pa = &a)
			{
				fixed (Matrix3x3* pb = &b)
				{
					int ret = Matrix3AreEqualNative((Matrix3x3*)pa, (Matrix3x3*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 3x3 matrices are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3AreEqualEpsilon")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int Matrix3AreEqualEpsilonNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] Matrix3x3* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] Matrix3x3* b, [NativeName(NativeNameType.Param, "epsilon")] [NativeName(NativeNameType.Type, "float const")] float epsilon)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Matrix3x3*, Matrix3x3*, float, int>)funcTable[78])(a, b, epsilon);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, float, int>)funcTable[78])((nint)a, (nint)b, epsilon);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 3x3 matrices are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3AreEqualEpsilon")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Matrix3AreEqualEpsilon([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] Matrix3x3* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] Matrix3x3* b, [NativeName(NativeNameType.Param, "epsilon")] [NativeName(NativeNameType.Type, "float const")] float epsilon)
		{
			int ret = Matrix3AreEqualEpsilonNative(a, b, epsilon);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 3x3 matrices are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3AreEqualEpsilon")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Matrix3AreEqualEpsilon([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] ref Matrix3x3 a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] Matrix3x3* b, [NativeName(NativeNameType.Param, "epsilon")] [NativeName(NativeNameType.Type, "float const")] float epsilon)
		{
			fixed (Matrix3x3* pa = &a)
			{
				int ret = Matrix3AreEqualEpsilonNative((Matrix3x3*)pa, b, epsilon);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 3x3 matrices are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3AreEqualEpsilon")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Matrix3AreEqualEpsilon([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] Matrix3x3* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] ref Matrix3x3 b, [NativeName(NativeNameType.Param, "epsilon")] [NativeName(NativeNameType.Type, "float const")] float epsilon)
		{
			fixed (Matrix3x3* pb = &b)
			{
				int ret = Matrix3AreEqualEpsilonNative(a, (Matrix3x3*)pb, epsilon);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 3x3 matrices are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3AreEqualEpsilon")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Matrix3AreEqualEpsilon([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] ref Matrix3x3 a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] ref Matrix3x3 b, [NativeName(NativeNameType.Param, "epsilon")] [NativeName(NativeNameType.Type, "float const")] float epsilon)
		{
			fixed (Matrix3x3* pa = &a)
			{
				fixed (Matrix3x3* pb = &b)
				{
					int ret = Matrix3AreEqualEpsilonNative((Matrix3x3*)pa, (Matrix3x3*)pb, epsilon);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Invert a 3x3 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3Inverse")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Matrix3InverseNative([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] Matrix3x3* mat)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Matrix3x3*, void>)funcTable[79])(mat);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[79])((nint)mat);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Invert a 3x3 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3Inverse")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix3Inverse([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] Matrix3x3* mat)
		{
			Matrix3InverseNative(mat);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Invert a 3x3 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3Inverse")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix3Inverse([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] ref Matrix3x3 mat)
		{
			fixed (Matrix3x3* pmat = &mat)
			{
				Matrix3InverseNative((Matrix3x3*)pmat);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the determinant of a 3x3 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3Determinant")]
		[return: NativeName(NativeNameType.Type, "ai_real")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double Matrix3DeterminantNative([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] Matrix3x3* mat)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Matrix3x3*, double>)funcTable[80])(mat);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, double>)funcTable[80])((nint)mat);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the determinant of a 3x3 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3Determinant")]
		[return: NativeName(NativeNameType.Type, "ai_real")]
		public static double Matrix3Determinant([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] Matrix3x3* mat)
		{
			double ret = Matrix3DeterminantNative(mat);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the determinant of a 3x3 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3Determinant")]
		[return: NativeName(NativeNameType.Type, "ai_real")]
		public static double Matrix3Determinant([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] ref Matrix3x3 mat)
		{
			fixed (Matrix3x3* pmat = &mat)
			{
				double ret = Matrix3DeterminantNative((Matrix3x3*)pmat);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 3x3 rotation matrix around the Z axis.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3RotationZ")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Matrix3RotationZNative([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] Matrix3x3* mat, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "float const")] float angle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Matrix3x3*, float, void>)funcTable[81])(mat, angle);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, void>)funcTable[81])((nint)mat, angle);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 3x3 rotation matrix around the Z axis.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3RotationZ")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix3RotationZ([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] Matrix3x3* mat, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "float const")] float angle)
		{
			Matrix3RotationZNative(mat, angle);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 3x3 rotation matrix around the Z axis.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3RotationZ")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix3RotationZ([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] ref Matrix3x3 mat, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "float const")] float angle)
		{
			fixed (Matrix3x3* pmat = &mat)
			{
				Matrix3RotationZNative((Matrix3x3*)pmat, angle);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns a 3x3 rotation matrix for a rotation around an arbitrary axis.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3FromRotationAroundAxis")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Matrix3FromRotationAroundAxisNative([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] Matrix3x3* mat, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "float const")] float angle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Matrix3x3*, Vector3*, float, void>)funcTable[82])(mat, axis, angle);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, float, void>)funcTable[82])((nint)mat, (nint)axis, angle);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns a 3x3 rotation matrix for a rotation around an arbitrary axis.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3FromRotationAroundAxis")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix3FromRotationAroundAxis([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] Matrix3x3* mat, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "float const")] float angle)
		{
			Matrix3FromRotationAroundAxisNative(mat, axis, angle);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns a 3x3 rotation matrix for a rotation around an arbitrary axis.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3FromRotationAroundAxis")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix3FromRotationAroundAxis([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] ref Matrix3x3 mat, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "float const")] float angle)
		{
			fixed (Matrix3x3* pmat = &mat)
			{
				Matrix3FromRotationAroundAxisNative((Matrix3x3*)pmat, axis, angle);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns a 3x3 rotation matrix for a rotation around an arbitrary axis.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3FromRotationAroundAxis")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix3FromRotationAroundAxis([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] Matrix3x3* mat, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "float const")] float angle)
		{
			fixed (Vector3* paxis = &axis)
			{
				Matrix3FromRotationAroundAxisNative(mat, (Vector3*)paxis, angle);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns a 3x3 rotation matrix for a rotation around an arbitrary axis.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3FromRotationAroundAxis")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix3FromRotationAroundAxis([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] ref Matrix3x3 mat, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "float const")] float angle)
		{
			fixed (Matrix3x3* pmat = &mat)
			{
				fixed (Vector3* paxis = &axis)
				{
					Matrix3FromRotationAroundAxisNative((Matrix3x3*)pmat, (Vector3*)paxis, angle);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 3x3 translation matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3Translation")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Matrix3TranslationNative([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] Matrix3x3* mat, [NativeName(NativeNameType.Param, "translation")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* translation)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Matrix3x3*, Vector2*, void>)funcTable[83])(mat, translation);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[83])((nint)mat, (nint)translation);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 3x3 translation matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3Translation")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix3Translation([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] Matrix3x3* mat, [NativeName(NativeNameType.Param, "translation")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* translation)
		{
			Matrix3TranslationNative(mat, translation);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 3x3 translation matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3Translation")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix3Translation([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] ref Matrix3x3 mat, [NativeName(NativeNameType.Param, "translation")] [NativeName(NativeNameType.Type, "aiVector2D const *")] Vector2* translation)
		{
			fixed (Matrix3x3* pmat = &mat)
			{
				Matrix3TranslationNative((Matrix3x3*)pmat, translation);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 3x3 translation matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3Translation")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix3Translation([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] Matrix3x3* mat, [NativeName(NativeNameType.Param, "translation")] [NativeName(NativeNameType.Type, "aiVector2D const *")] ref Vector2 translation)
		{
			fixed (Vector2* ptranslation = &translation)
			{
				Matrix3TranslationNative(mat, (Vector2*)ptranslation);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 3x3 translation matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3Translation")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix3Translation([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] ref Matrix3x3 mat, [NativeName(NativeNameType.Param, "translation")] [NativeName(NativeNameType.Type, "aiVector2D const *")] ref Vector2 translation)
		{
			fixed (Matrix3x3* pmat = &mat)
			{
				fixed (Vector2* ptranslation = &translation)
				{
					Matrix3TranslationNative((Matrix3x3*)pmat, (Vector2*)ptranslation);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a 3x3 matrix that rotates one vector to another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3FromTo")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Matrix3FromToNative([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] Matrix3x3* mat, [NativeName(NativeNameType.Param, "from")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* from, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* to)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Matrix3x3*, Vector3*, Vector3*, void>)funcTable[84])(mat, from, to);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[84])((nint)mat, (nint)from, (nint)to);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a 3x3 matrix that rotates one vector to another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3FromTo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix3FromTo([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] Matrix3x3* mat, [NativeName(NativeNameType.Param, "from")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* from, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* to)
		{
			Matrix3FromToNative(mat, from, to);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a 3x3 matrix that rotates one vector to another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3FromTo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix3FromTo([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] ref Matrix3x3 mat, [NativeName(NativeNameType.Param, "from")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* from, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* to)
		{
			fixed (Matrix3x3* pmat = &mat)
			{
				Matrix3FromToNative((Matrix3x3*)pmat, from, to);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a 3x3 matrix that rotates one vector to another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3FromTo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix3FromTo([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] Matrix3x3* mat, [NativeName(NativeNameType.Param, "from")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 from, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* to)
		{
			fixed (Vector3* pfrom = &from)
			{
				Matrix3FromToNative(mat, (Vector3*)pfrom, to);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a 3x3 matrix that rotates one vector to another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3FromTo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix3FromTo([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] ref Matrix3x3 mat, [NativeName(NativeNameType.Param, "from")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 from, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* to)
		{
			fixed (Matrix3x3* pmat = &mat)
			{
				fixed (Vector3* pfrom = &from)
				{
					Matrix3FromToNative((Matrix3x3*)pmat, (Vector3*)pfrom, to);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a 3x3 matrix that rotates one vector to another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3FromTo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix3FromTo([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] Matrix3x3* mat, [NativeName(NativeNameType.Param, "from")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* from, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 to)
		{
			fixed (Vector3* pto = &to)
			{
				Matrix3FromToNative(mat, from, (Vector3*)pto);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a 3x3 matrix that rotates one vector to another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3FromTo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix3FromTo([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] ref Matrix3x3 mat, [NativeName(NativeNameType.Param, "from")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* from, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 to)
		{
			fixed (Matrix3x3* pmat = &mat)
			{
				fixed (Vector3* pto = &to)
				{
					Matrix3FromToNative((Matrix3x3*)pmat, from, (Vector3*)pto);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a 3x3 matrix that rotates one vector to another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3FromTo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix3FromTo([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] Matrix3x3* mat, [NativeName(NativeNameType.Param, "from")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 from, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 to)
		{
			fixed (Vector3* pfrom = &from)
			{
				fixed (Vector3* pto = &to)
				{
					Matrix3FromToNative(mat, (Vector3*)pfrom, (Vector3*)pto);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a 3x3 matrix that rotates one vector to another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix3FromTo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix3FromTo([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 *")] ref Matrix3x3 mat, [NativeName(NativeNameType.Param, "from")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 from, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 to)
		{
			fixed (Matrix3x3* pmat = &mat)
			{
				fixed (Vector3* pfrom = &from)
				{
					fixed (Vector3* pto = &to)
					{
						Matrix3FromToNative((Matrix3x3*)pmat, (Vector3*)pfrom, (Vector3*)pto);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 4x4 matrix from a 3x3 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromMatrix3")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Matrix4FromMatrix3Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* dst, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] Matrix3x3* mat)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Matrix4x4*, Matrix3x3*, void>)funcTable[85])(dst, mat);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[85])((nint)dst, (nint)mat);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 4x4 matrix from a 3x3 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromMatrix3")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromMatrix3([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* dst, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] Matrix3x3* mat)
		{
			Matrix4FromMatrix3Native(dst, mat);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 4x4 matrix from a 3x3 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromMatrix3")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromMatrix3([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 dst, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] Matrix3x3* mat)
		{
			fixed (Matrix4x4* pdst = &dst)
			{
				Matrix4FromMatrix3Native((Matrix4x4*)pdst, mat);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 4x4 matrix from a 3x3 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromMatrix3")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromMatrix3([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* dst, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] ref Matrix3x3 mat)
		{
			fixed (Matrix3x3* pmat = &mat)
			{
				Matrix4FromMatrix3Native(dst, (Matrix3x3*)pmat);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 4x4 matrix from a 3x3 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromMatrix3")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromMatrix3([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 dst, [NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix3x3 const *")] ref Matrix3x3 mat)
		{
			fixed (Matrix4x4* pdst = &dst)
			{
				fixed (Matrix3x3* pmat = &mat)
				{
					Matrix4FromMatrix3Native((Matrix4x4*)pdst, (Matrix3x3*)pmat);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 4x4 matrix from scaling, rotation and position.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromScalingQuaternionPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Matrix4FromScalingQuaternionPositionNative([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* position)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Matrix4x4*, Vector3*, Quaternion*, Vector3*, void>)funcTable[86])(mat, scaling, rotation, position);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, void>)funcTable[86])((nint)mat, (nint)scaling, (nint)rotation, (nint)position);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 4x4 matrix from scaling, rotation and position.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromScalingQuaternionPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromScalingQuaternionPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* position)
		{
			Matrix4FromScalingQuaternionPositionNative(mat, scaling, rotation, position);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 4x4 matrix from scaling, rotation and position.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromScalingQuaternionPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromScalingQuaternionPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				Matrix4FromScalingQuaternionPositionNative((Matrix4x4*)pmat, scaling, rotation, position);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 4x4 matrix from scaling, rotation and position.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromScalingQuaternionPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromScalingQuaternionPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* position)
		{
			fixed (Vector3* pscaling = &scaling)
			{
				Matrix4FromScalingQuaternionPositionNative(mat, (Vector3*)pscaling, rotation, position);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 4x4 matrix from scaling, rotation and position.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromScalingQuaternionPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromScalingQuaternionPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* pscaling = &scaling)
				{
					Matrix4FromScalingQuaternionPositionNative((Matrix4x4*)pmat, (Vector3*)pscaling, rotation, position);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 4x4 matrix from scaling, rotation and position.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromScalingQuaternionPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromScalingQuaternionPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* position)
		{
			fixed (Quaternion* protation = &rotation)
			{
				Matrix4FromScalingQuaternionPositionNative(mat, scaling, (Quaternion*)protation, position);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 4x4 matrix from scaling, rotation and position.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromScalingQuaternionPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromScalingQuaternionPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Quaternion* protation = &rotation)
				{
					Matrix4FromScalingQuaternionPositionNative((Matrix4x4*)pmat, scaling, (Quaternion*)protation, position);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 4x4 matrix from scaling, rotation and position.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromScalingQuaternionPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromScalingQuaternionPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* position)
		{
			fixed (Vector3* pscaling = &scaling)
			{
				fixed (Quaternion* protation = &rotation)
				{
					Matrix4FromScalingQuaternionPositionNative(mat, (Vector3*)pscaling, (Quaternion*)protation, position);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 4x4 matrix from scaling, rotation and position.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromScalingQuaternionPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromScalingQuaternionPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* pscaling = &scaling)
				{
					fixed (Quaternion* protation = &rotation)
					{
						Matrix4FromScalingQuaternionPositionNative((Matrix4x4*)pmat, (Vector3*)pscaling, (Quaternion*)protation, position);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 4x4 matrix from scaling, rotation and position.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromScalingQuaternionPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromScalingQuaternionPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 position)
		{
			fixed (Vector3* pposition = &position)
			{
				Matrix4FromScalingQuaternionPositionNative(mat, scaling, rotation, (Vector3*)pposition);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 4x4 matrix from scaling, rotation and position.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromScalingQuaternionPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromScalingQuaternionPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* pposition = &position)
				{
					Matrix4FromScalingQuaternionPositionNative((Matrix4x4*)pmat, scaling, rotation, (Vector3*)pposition);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 4x4 matrix from scaling, rotation and position.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromScalingQuaternionPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromScalingQuaternionPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 position)
		{
			fixed (Vector3* pscaling = &scaling)
			{
				fixed (Vector3* pposition = &position)
				{
					Matrix4FromScalingQuaternionPositionNative(mat, (Vector3*)pscaling, rotation, (Vector3*)pposition);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 4x4 matrix from scaling, rotation and position.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromScalingQuaternionPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromScalingQuaternionPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* pscaling = &scaling)
				{
					fixed (Vector3* pposition = &position)
					{
						Matrix4FromScalingQuaternionPositionNative((Matrix4x4*)pmat, (Vector3*)pscaling, rotation, (Vector3*)pposition);
					}
				}
			}
		}
	}
}
