// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.Assimp
{
	public unsafe partial class Assimp
	{
		/// <summary>
		/// <br/>
		/// Will return a nullptr if no assigned importer desc. was found for the given extension<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetImporterDesc")]
		[return: NativeName(NativeNameType.Type, "aiImporterDesc const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static AiImporterDesc* GetImporterDescNative([NativeName(NativeNameType.Param, "extension")] [NativeName(NativeNameType.Type, "char const *")] byte* extension)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, AiImporterDesc*>)funcTable[0])(extension);
			#else
			return (AiImporterDesc*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[0])((nint)extension);
			#endif
		}

		/// <summary>
		/// <br/>
		/// Will return a nullptr if no assigned importer desc. was found for the given extension<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetImporterDesc")]
		[return: NativeName(NativeNameType.Type, "aiImporterDesc const *")]
		public static AiImporterDesc* GetImporterDesc([NativeName(NativeNameType.Param, "extension")] [NativeName(NativeNameType.Type, "char const *")] byte* extension)
		{
			AiImporterDesc* ret = GetImporterDescNative(extension);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// Will return a nullptr if no assigned importer desc. was found for the given extension<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetImporterDesc")]
		[return: NativeName(NativeNameType.Type, "aiImporterDesc const *")]
		public static AiImporterDesc* GetImporterDesc([NativeName(NativeNameType.Param, "extension")] [NativeName(NativeNameType.Type, "char const *")] ref byte extension)
		{
			fixed (byte* pextension = &extension)
			{
				AiImporterDesc* ret = GetImporterDescNative((byte*)pextension);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// Will return a nullptr if no assigned importer desc. was found for the given extension<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetImporterDesc")]
		[return: NativeName(NativeNameType.Type, "aiImporterDesc const *")]
		public static AiImporterDesc* GetImporterDesc([NativeName(NativeNameType.Param, "extension")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> extension)
		{
			fixed (byte* pextension = extension)
			{
				AiImporterDesc* ret = GetImporterDescNative((byte*)pextension);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// Will return a nullptr if no assigned importer desc. was found for the given extension<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetImporterDesc")]
		[return: NativeName(NativeNameType.Type, "aiImporterDesc const *")]
		public static AiImporterDesc* GetImporterDesc([NativeName(NativeNameType.Param, "extension")] [NativeName(NativeNameType.Type, "char const *")] string extension)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (extension != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(extension);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(extension, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AiImporterDesc* ret = GetImporterDescNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns the number of export file formats available in the current Assimp build.<br/>
		/// Use aiGetExportFormatDescription() to retrieve infos of a specific export format.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetExportFormatCount")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint GetExportFormatCountNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<nuint>)funcTable[1])();
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nuint>)funcTable[1])();
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns the number of export file formats available in the current Assimp build.<br/>
		/// Use aiGetExportFormatDescription() to retrieve infos of a specific export format.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetExportFormatCount")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint GetExportFormatCount()
		{
			nuint ret = GetExportFormatCountNative();
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns a description of the nth export file format. Use #aiGetExportFormatCount()<br/>
		/// to learn how many export formats are supported. The description must be released by<br/>
		/// calling aiReleaseExportFormatDescription afterwards.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetExportFormatDescription")]
		[return: NativeName(NativeNameType.Type, "aiExportFormatDesc const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static AiExportFormatDesc* GetExportFormatDescriptionNative([NativeName(NativeNameType.Param, "pIndex")] [NativeName(NativeNameType.Type, "size_t")] nuint pIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<nuint, AiExportFormatDesc*>)funcTable[2])(pIndex);
			#else
			return (AiExportFormatDesc*)((delegate* unmanaged[Cdecl]<nuint, nint>)funcTable[2])(pIndex);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns a description of the nth export file format. Use #aiGetExportFormatCount()<br/>
		/// to learn how many export formats are supported. The description must be released by<br/>
		/// calling aiReleaseExportFormatDescription afterwards.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetExportFormatDescription")]
		[return: NativeName(NativeNameType.Type, "aiExportFormatDesc const *")]
		public static AiExportFormatDesc* GetExportFormatDescription([NativeName(NativeNameType.Param, "pIndex")] [NativeName(NativeNameType.Type, "size_t")] nuint pIndex)
		{
			AiExportFormatDesc* ret = GetExportFormatDescriptionNative(pIndex);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Release a description of the nth export file format. Must be returned by<br/>
		/// aiGetExportFormatDescription<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiReleaseExportFormatDescription")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReleaseExportFormatDescriptionNative([NativeName(NativeNameType.Param, "desc")] [NativeName(NativeNameType.Type, "aiExportFormatDesc const *")] AiExportFormatDesc* desc)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<AiExportFormatDesc*, void>)funcTable[3])(desc);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[3])((nint)desc);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Release a description of the nth export file format. Must be returned by<br/>
		/// aiGetExportFormatDescription<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiReleaseExportFormatDescription")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseExportFormatDescription([NativeName(NativeNameType.Param, "desc")] [NativeName(NativeNameType.Type, "aiExportFormatDesc const *")] AiExportFormatDesc* desc)
		{
			ReleaseExportFormatDescriptionNative(desc);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Release a description of the nth export file format. Must be returned by<br/>
		/// aiGetExportFormatDescription<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiReleaseExportFormatDescription")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseExportFormatDescription([NativeName(NativeNameType.Param, "desc")] [NativeName(NativeNameType.Type, "aiExportFormatDesc const *")] ref AiExportFormatDesc desc)
		{
			fixed (AiExportFormatDesc* pdesc = &desc)
			{
				ReleaseExportFormatDescriptionNative((AiExportFormatDesc*)pdesc);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a modifiable copy of a scene.<br/>
		/// This is useful to import files via Assimp, change their topology and<br/>
		/// export them again. Since the scene returned by the various importer functions<br/>
		/// is const, a modifiable copy is needed.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiCopyScene")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopySceneNative([NativeName(NativeNameType.Param, "pIn")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pIn, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "aiScene * *")] AiScene** pOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<AiScene*, AiScene**, void>)funcTable[4])(pIn, pOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[4])((nint)pIn, (nint)pOut);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a modifiable copy of a scene.<br/>
		/// This is useful to import files via Assimp, change their topology and<br/>
		/// export them again. Since the scene returned by the various importer functions<br/>
		/// is const, a modifiable copy is needed.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiCopyScene")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyScene([NativeName(NativeNameType.Param, "pIn")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pIn, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "aiScene * *")] AiScene** pOut)
		{
			CopySceneNative(pIn, pOut);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a modifiable copy of a scene.<br/>
		/// This is useful to import files via Assimp, change their topology and<br/>
		/// export them again. Since the scene returned by the various importer functions<br/>
		/// is const, a modifiable copy is needed.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiCopyScene")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyScene([NativeName(NativeNameType.Param, "pIn")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pIn, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "aiScene * *")] AiScene** pOut)
		{
			fixed (AiScene* ppIn = &pIn)
			{
				CopySceneNative((AiScene*)ppIn, pOut);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a modifiable copy of a scene.<br/>
		/// This is useful to import files via Assimp, change their topology and<br/>
		/// export them again. Since the scene returned by the various importer functions<br/>
		/// is const, a modifiable copy is needed.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiCopyScene")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyScene([NativeName(NativeNameType.Param, "pIn")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pIn, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "aiScene * *")] ref AiScene* pOut)
		{
			fixed (AiScene** ppOut = &pOut)
			{
				CopySceneNative(pIn, (AiScene**)ppOut);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a modifiable copy of a scene.<br/>
		/// This is useful to import files via Assimp, change their topology and<br/>
		/// export them again. Since the scene returned by the various importer functions<br/>
		/// is const, a modifiable copy is needed.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiCopyScene")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyScene([NativeName(NativeNameType.Param, "pIn")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pIn, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "aiScene * *")] ref AiScene* pOut)
		{
			fixed (AiScene* ppIn = &pIn)
			{
				fixed (AiScene** ppOut = &pOut)
				{
					CopySceneNative((AiScene*)ppIn, (AiScene**)ppOut);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Frees a scene copy created using aiCopyScene() <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiFreeScene")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FreeSceneNative([NativeName(NativeNameType.Param, "pIn")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pIn)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<AiScene*, void>)funcTable[5])(pIn);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[5])((nint)pIn);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Frees a scene copy created using aiCopyScene() <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiFreeScene")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FreeScene([NativeName(NativeNameType.Param, "pIn")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pIn)
		{
			FreeSceneNative(pIn);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Frees a scene copy created using aiCopyScene() <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiFreeScene")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FreeScene([NativeName(NativeNameType.Param, "pIn")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pIn)
		{
			fixed (AiScene* ppIn = &pIn)
			{
				FreeSceneNative((AiScene*)ppIn);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format and writes the result file(s) to disk.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportScene")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static AiReturn ExportSceneNative([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] byte* pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* pFileName, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<AiScene*, byte*, byte*, uint, AiReturn>)funcTable[6])(pScene, pFormatId, pFileName, pPreprocessing);
			#else
			return (AiReturn)((delegate* unmanaged[Cdecl]<nint, nint, nint, uint, AiReturn>)funcTable[6])((nint)pScene, (nint)pFormatId, (nint)pFileName, pPreprocessing);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format and writes the result file(s) to disk.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportScene")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportScene([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] byte* pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* pFileName, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			AiReturn ret = ExportSceneNative(pScene, pFormatId, pFileName, pPreprocessing);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format and writes the result file(s) to disk.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportScene")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportScene([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] byte* pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* pFileName, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				AiReturn ret = ExportSceneNative((AiScene*)ppScene, pFormatId, pFileName, pPreprocessing);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format and writes the result file(s) to disk.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportScene")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportScene([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* pFileName, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (byte* ppFormatId = &pFormatId)
			{
				AiReturn ret = ExportSceneNative(pScene, (byte*)ppFormatId, pFileName, pPreprocessing);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format and writes the result file(s) to disk.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportScene")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportScene([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* pFileName, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (byte* ppFormatId = pFormatId)
			{
				AiReturn ret = ExportSceneNative(pScene, (byte*)ppFormatId, pFileName, pPreprocessing);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format and writes the result file(s) to disk.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportScene")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportScene([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] string pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* pFileName, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pFormatId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pFormatId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pFormatId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AiReturn ret = ExportSceneNative(pScene, pStr0, pFileName, pPreprocessing);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format and writes the result file(s) to disk.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportScene")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportScene([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* pFileName, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				fixed (byte* ppFormatId = &pFormatId)
				{
					AiReturn ret = ExportSceneNative((AiScene*)ppScene, (byte*)ppFormatId, pFileName, pPreprocessing);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format and writes the result file(s) to disk.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportScene")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportScene([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* pFileName, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				fixed (byte* ppFormatId = pFormatId)
				{
					AiReturn ret = ExportSceneNative((AiScene*)ppScene, (byte*)ppFormatId, pFileName, pPreprocessing);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format and writes the result file(s) to disk.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportScene")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportScene([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] string pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* pFileName, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pFormatId != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pFormatId);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pFormatId, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AiReturn ret = ExportSceneNative((AiScene*)ppScene, pStr0, pFileName, pPreprocessing);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format and writes the result file(s) to disk.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportScene")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportScene([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] byte* pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFileName, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (byte* ppFileName = &pFileName)
			{
				AiReturn ret = ExportSceneNative(pScene, pFormatId, (byte*)ppFileName, pPreprocessing);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format and writes the result file(s) to disk.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportScene")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportScene([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] byte* pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFileName, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (byte* ppFileName = pFileName)
			{
				AiReturn ret = ExportSceneNative(pScene, pFormatId, (byte*)ppFileName, pPreprocessing);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format and writes the result file(s) to disk.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportScene")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportScene([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] byte* pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] string pFileName, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AiReturn ret = ExportSceneNative(pScene, pFormatId, pStr0, pPreprocessing);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format and writes the result file(s) to disk.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportScene")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportScene([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] byte* pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFileName, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				fixed (byte* ppFileName = &pFileName)
				{
					AiReturn ret = ExportSceneNative((AiScene*)ppScene, pFormatId, (byte*)ppFileName, pPreprocessing);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format and writes the result file(s) to disk.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportScene")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportScene([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] byte* pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFileName, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				fixed (byte* ppFileName = pFileName)
				{
					AiReturn ret = ExportSceneNative((AiScene*)ppScene, pFormatId, (byte*)ppFileName, pPreprocessing);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format and writes the result file(s) to disk.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportScene")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportScene([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] byte* pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] string pFileName, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pFileName != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pFileName);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pFileName, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AiReturn ret = ExportSceneNative((AiScene*)ppScene, pFormatId, pStr0, pPreprocessing);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format and writes the result file(s) to disk.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportScene")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportScene([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFileName, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (byte* ppFormatId = &pFormatId)
			{
				fixed (byte* ppFileName = &pFileName)
				{
					AiReturn ret = ExportSceneNative(pScene, (byte*)ppFormatId, (byte*)ppFileName, pPreprocessing);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format and writes the result file(s) to disk.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportScene")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportScene([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFileName, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (byte* ppFormatId = pFormatId)
			{
				fixed (byte* ppFileName = pFileName)
				{
					AiReturn ret = ExportSceneNative(pScene, (byte*)ppFormatId, (byte*)ppFileName, pPreprocessing);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format and writes the result file(s) to disk.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportScene")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportScene([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] string pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] string pFileName, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pFormatId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pFormatId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pFormatId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (pFileName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(pFileName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(pFileName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			AiReturn ret = ExportSceneNative(pScene, pStr0, pStr1, pPreprocessing);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format and writes the result file(s) to disk.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportScene")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportScene([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFileName, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				fixed (byte* ppFormatId = &pFormatId)
				{
					fixed (byte* ppFileName = &pFileName)
					{
						AiReturn ret = ExportSceneNative((AiScene*)ppScene, (byte*)ppFormatId, (byte*)ppFileName, pPreprocessing);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format and writes the result file(s) to disk.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportScene")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportScene([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFileName, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				fixed (byte* ppFormatId = pFormatId)
				{
					fixed (byte* ppFileName = pFileName)
					{
						AiReturn ret = ExportSceneNative((AiScene*)ppScene, (byte*)ppFormatId, (byte*)ppFileName, pPreprocessing);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format and writes the result file(s) to disk.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportScene")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportScene([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] string pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] string pFileName, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pFormatId != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pFormatId);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pFormatId, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (pFileName != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(pFileName);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(pFileName, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				AiReturn ret = ExportSceneNative((AiScene*)ppScene, pStr0, pStr1, pPreprocessing);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static AiReturn ExportSceneExNative([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] byte* pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<AiScene*, byte*, byte*, AiFileIO*, uint, AiReturn>)funcTable[7])(pScene, pFormatId, pFileName, piO, pPreprocessing);
			#else
			return (AiReturn)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, uint, AiReturn>)funcTable[7])((nint)pScene, (nint)pFormatId, (nint)pFileName, (nint)piO, pPreprocessing);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] byte* pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			AiReturn ret = ExportSceneExNative(pScene, pFormatId, pFileName, piO, pPreprocessing);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] byte* pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				AiReturn ret = ExportSceneExNative((AiScene*)ppScene, pFormatId, pFileName, piO, pPreprocessing);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (byte* ppFormatId = &pFormatId)
			{
				AiReturn ret = ExportSceneExNative(pScene, (byte*)ppFormatId, pFileName, piO, pPreprocessing);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (byte* ppFormatId = pFormatId)
			{
				AiReturn ret = ExportSceneExNative(pScene, (byte*)ppFormatId, pFileName, piO, pPreprocessing);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] string pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pFormatId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pFormatId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pFormatId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AiReturn ret = ExportSceneExNative(pScene, pStr0, pFileName, piO, pPreprocessing);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				fixed (byte* ppFormatId = &pFormatId)
				{
					AiReturn ret = ExportSceneExNative((AiScene*)ppScene, (byte*)ppFormatId, pFileName, piO, pPreprocessing);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				fixed (byte* ppFormatId = pFormatId)
				{
					AiReturn ret = ExportSceneExNative((AiScene*)ppScene, (byte*)ppFormatId, pFileName, piO, pPreprocessing);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] string pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pFormatId != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pFormatId);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pFormatId, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AiReturn ret = ExportSceneExNative((AiScene*)ppScene, pStr0, pFileName, piO, pPreprocessing);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] byte* pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (byte* ppFileName = &pFileName)
			{
				AiReturn ret = ExportSceneExNative(pScene, pFormatId, (byte*)ppFileName, piO, pPreprocessing);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] byte* pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (byte* ppFileName = pFileName)
			{
				AiReturn ret = ExportSceneExNative(pScene, pFormatId, (byte*)ppFileName, piO, pPreprocessing);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] byte* pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] string pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AiReturn ret = ExportSceneExNative(pScene, pFormatId, pStr0, piO, pPreprocessing);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] byte* pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				fixed (byte* ppFileName = &pFileName)
				{
					AiReturn ret = ExportSceneExNative((AiScene*)ppScene, pFormatId, (byte*)ppFileName, piO, pPreprocessing);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] byte* pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				fixed (byte* ppFileName = pFileName)
				{
					AiReturn ret = ExportSceneExNative((AiScene*)ppScene, pFormatId, (byte*)ppFileName, piO, pPreprocessing);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] byte* pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] string pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pFileName != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pFileName);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pFileName, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AiReturn ret = ExportSceneExNative((AiScene*)ppScene, pFormatId, pStr0, piO, pPreprocessing);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (byte* ppFormatId = &pFormatId)
			{
				fixed (byte* ppFileName = &pFileName)
				{
					AiReturn ret = ExportSceneExNative(pScene, (byte*)ppFormatId, (byte*)ppFileName, piO, pPreprocessing);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (byte* ppFormatId = pFormatId)
			{
				fixed (byte* ppFileName = pFileName)
				{
					AiReturn ret = ExportSceneExNative(pScene, (byte*)ppFormatId, (byte*)ppFileName, piO, pPreprocessing);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] string pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] string pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pFormatId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pFormatId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pFormatId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (pFileName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(pFileName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(pFileName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			AiReturn ret = ExportSceneExNative(pScene, pStr0, pStr1, piO, pPreprocessing);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				fixed (byte* ppFormatId = &pFormatId)
				{
					fixed (byte* ppFileName = &pFileName)
					{
						AiReturn ret = ExportSceneExNative((AiScene*)ppScene, (byte*)ppFormatId, (byte*)ppFileName, piO, pPreprocessing);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				fixed (byte* ppFormatId = pFormatId)
				{
					fixed (byte* ppFileName = pFileName)
					{
						AiReturn ret = ExportSceneExNative((AiScene*)ppScene, (byte*)ppFormatId, (byte*)ppFileName, piO, pPreprocessing);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] string pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] string pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pFormatId != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pFormatId);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pFormatId, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (pFileName != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(pFileName);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(pFileName, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				AiReturn ret = ExportSceneExNative((AiScene*)ppScene, pStr0, pStr1, piO, pPreprocessing);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] byte* pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiFileIO* ppiO = &piO)
			{
				AiReturn ret = ExportSceneExNative(pScene, pFormatId, pFileName, (AiFileIO*)ppiO, pPreprocessing);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] byte* pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				fixed (AiFileIO* ppiO = &piO)
				{
					AiReturn ret = ExportSceneExNative((AiScene*)ppScene, pFormatId, pFileName, (AiFileIO*)ppiO, pPreprocessing);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (byte* ppFormatId = &pFormatId)
			{
				fixed (AiFileIO* ppiO = &piO)
				{
					AiReturn ret = ExportSceneExNative(pScene, (byte*)ppFormatId, pFileName, (AiFileIO*)ppiO, pPreprocessing);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (byte* ppFormatId = pFormatId)
			{
				fixed (AiFileIO* ppiO = &piO)
				{
					AiReturn ret = ExportSceneExNative(pScene, (byte*)ppFormatId, pFileName, (AiFileIO*)ppiO, pPreprocessing);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] string pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pFormatId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pFormatId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pFormatId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (AiFileIO* ppiO = &piO)
			{
				AiReturn ret = ExportSceneExNative(pScene, pStr0, pFileName, (AiFileIO*)ppiO, pPreprocessing);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				fixed (byte* ppFormatId = &pFormatId)
				{
					fixed (AiFileIO* ppiO = &piO)
					{
						AiReturn ret = ExportSceneExNative((AiScene*)ppScene, (byte*)ppFormatId, pFileName, (AiFileIO*)ppiO, pPreprocessing);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				fixed (byte* ppFormatId = pFormatId)
				{
					fixed (AiFileIO* ppiO = &piO)
					{
						AiReturn ret = ExportSceneExNative((AiScene*)ppScene, (byte*)ppFormatId, pFileName, (AiFileIO*)ppiO, pPreprocessing);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] string pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] byte* pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pFormatId != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pFormatId);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pFormatId, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (AiFileIO* ppiO = &piO)
				{
					AiReturn ret = ExportSceneExNative((AiScene*)ppScene, pStr0, pFileName, (AiFileIO*)ppiO, pPreprocessing);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] byte* pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (byte* ppFileName = &pFileName)
			{
				fixed (AiFileIO* ppiO = &piO)
				{
					AiReturn ret = ExportSceneExNative(pScene, pFormatId, (byte*)ppFileName, (AiFileIO*)ppiO, pPreprocessing);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] byte* pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (byte* ppFileName = pFileName)
			{
				fixed (AiFileIO* ppiO = &piO)
				{
					AiReturn ret = ExportSceneExNative(pScene, pFormatId, (byte*)ppFileName, (AiFileIO*)ppiO, pPreprocessing);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] byte* pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] string pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (AiFileIO* ppiO = &piO)
			{
				AiReturn ret = ExportSceneExNative(pScene, pFormatId, pStr0, (AiFileIO*)ppiO, pPreprocessing);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] byte* pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				fixed (byte* ppFileName = &pFileName)
				{
					fixed (AiFileIO* ppiO = &piO)
					{
						AiReturn ret = ExportSceneExNative((AiScene*)ppScene, pFormatId, (byte*)ppFileName, (AiFileIO*)ppiO, pPreprocessing);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] byte* pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				fixed (byte* ppFileName = pFileName)
				{
					fixed (AiFileIO* ppiO = &piO)
					{
						AiReturn ret = ExportSceneExNative((AiScene*)ppScene, pFormatId, (byte*)ppFileName, (AiFileIO*)ppiO, pPreprocessing);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] byte* pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] string pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pFileName != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pFileName);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pFileName, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (AiFileIO* ppiO = &piO)
				{
					AiReturn ret = ExportSceneExNative((AiScene*)ppScene, pFormatId, pStr0, (AiFileIO*)ppiO, pPreprocessing);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (byte* ppFormatId = &pFormatId)
			{
				fixed (byte* ppFileName = &pFileName)
				{
					fixed (AiFileIO* ppiO = &piO)
					{
						AiReturn ret = ExportSceneExNative(pScene, (byte*)ppFormatId, (byte*)ppFileName, (AiFileIO*)ppiO, pPreprocessing);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (byte* ppFormatId = pFormatId)
			{
				fixed (byte* ppFileName = pFileName)
				{
					fixed (AiFileIO* ppiO = &piO)
					{
						AiReturn ret = ExportSceneExNative(pScene, (byte*)ppFormatId, (byte*)ppFileName, (AiFileIO*)ppiO, pPreprocessing);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] string pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] string pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pFormatId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pFormatId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pFormatId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (pFileName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(pFileName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(pFileName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (AiFileIO* ppiO = &piO)
			{
				AiReturn ret = ExportSceneExNative(pScene, pStr0, pStr1, (AiFileIO*)ppiO, pPreprocessing);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				fixed (byte* ppFormatId = &pFormatId)
				{
					fixed (byte* ppFileName = &pFileName)
					{
						fixed (AiFileIO* ppiO = &piO)
						{
							AiReturn ret = ExportSceneExNative((AiScene*)ppScene, (byte*)ppFormatId, (byte*)ppFileName, (AiFileIO*)ppiO, pPreprocessing);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				fixed (byte* ppFormatId = pFormatId)
				{
					fixed (byte* ppFileName = pFileName)
					{
						fixed (AiFileIO* ppiO = &piO)
						{
							AiReturn ret = ExportSceneExNative((AiScene*)ppScene, (byte*)ppFormatId, (byte*)ppFileName, (AiFileIO*)ppiO, pPreprocessing);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format using custom IO logic supplied by you.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneEx")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn ExportSceneEx([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] string pFormatId, [NativeName(NativeNameType.Param, "pFileName")] [NativeName(NativeNameType.Type, "char const *")] string pFileName, [NativeName(NativeNameType.Param, "pIO")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO piO, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pFormatId != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pFormatId);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pFormatId, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (pFileName != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(pFileName);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(pFileName, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (AiFileIO* ppiO = &piO)
				{
					AiReturn ret = ExportSceneExNative((AiScene*)ppScene, pStr0, pStr1, (AiFileIO*)ppiO, pPreprocessing);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format. Returns the exported data as a binary blob which<br/>
		/// you can write into a file or something. When you're done with the data, use #aiReleaseExportBlob()<br/>
		/// to free the resources associated with the export.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneToBlob")]
		[return: NativeName(NativeNameType.Type, "aiExportDataBlob const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static AiExportDataBlob* ExportSceneToBlobNative([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] byte* pFormatId, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<AiScene*, byte*, uint, AiExportDataBlob*>)funcTable[8])(pScene, pFormatId, pPreprocessing);
			#else
			return (AiExportDataBlob*)((delegate* unmanaged[Cdecl]<nint, nint, uint, nint>)funcTable[8])((nint)pScene, (nint)pFormatId, pPreprocessing);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format. Returns the exported data as a binary blob which<br/>
		/// you can write into a file or something. When you're done with the data, use #aiReleaseExportBlob()<br/>
		/// to free the resources associated with the export.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneToBlob")]
		[return: NativeName(NativeNameType.Type, "aiExportDataBlob const *")]
		public static AiExportDataBlob* ExportSceneToBlob([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] byte* pFormatId, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			AiExportDataBlob* ret = ExportSceneToBlobNative(pScene, pFormatId, pPreprocessing);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format. Returns the exported data as a binary blob which<br/>
		/// you can write into a file or something. When you're done with the data, use #aiReleaseExportBlob()<br/>
		/// to free the resources associated with the export.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneToBlob")]
		[return: NativeName(NativeNameType.Type, "aiExportDataBlob const *")]
		public static AiExportDataBlob* ExportSceneToBlob([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] byte* pFormatId, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				AiExportDataBlob* ret = ExportSceneToBlobNative((AiScene*)ppScene, pFormatId, pPreprocessing);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format. Returns the exported data as a binary blob which<br/>
		/// you can write into a file or something. When you're done with the data, use #aiReleaseExportBlob()<br/>
		/// to free the resources associated with the export.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneToBlob")]
		[return: NativeName(NativeNameType.Type, "aiExportDataBlob const *")]
		public static AiExportDataBlob* ExportSceneToBlob([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFormatId, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (byte* ppFormatId = &pFormatId)
			{
				AiExportDataBlob* ret = ExportSceneToBlobNative(pScene, (byte*)ppFormatId, pPreprocessing);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format. Returns the exported data as a binary blob which<br/>
		/// you can write into a file or something. When you're done with the data, use #aiReleaseExportBlob()<br/>
		/// to free the resources associated with the export.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneToBlob")]
		[return: NativeName(NativeNameType.Type, "aiExportDataBlob const *")]
		public static AiExportDataBlob* ExportSceneToBlob([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFormatId, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (byte* ppFormatId = pFormatId)
			{
				AiExportDataBlob* ret = ExportSceneToBlobNative(pScene, (byte*)ppFormatId, pPreprocessing);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format. Returns the exported data as a binary blob which<br/>
		/// you can write into a file or something. When you're done with the data, use #aiReleaseExportBlob()<br/>
		/// to free the resources associated with the export.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneToBlob")]
		[return: NativeName(NativeNameType.Type, "aiExportDataBlob const *")]
		public static AiExportDataBlob* ExportSceneToBlob([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] string pFormatId, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pFormatId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pFormatId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pFormatId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AiExportDataBlob* ret = ExportSceneToBlobNative(pScene, pStr0, pPreprocessing);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format. Returns the exported data as a binary blob which<br/>
		/// you can write into a file or something. When you're done with the data, use #aiReleaseExportBlob()<br/>
		/// to free the resources associated with the export.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneToBlob")]
		[return: NativeName(NativeNameType.Type, "aiExportDataBlob const *")]
		public static AiExportDataBlob* ExportSceneToBlob([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFormatId, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				fixed (byte* ppFormatId = &pFormatId)
				{
					AiExportDataBlob* ret = ExportSceneToBlobNative((AiScene*)ppScene, (byte*)ppFormatId, pPreprocessing);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format. Returns the exported data as a binary blob which<br/>
		/// you can write into a file or something. When you're done with the data, use #aiReleaseExportBlob()<br/>
		/// to free the resources associated with the export.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneToBlob")]
		[return: NativeName(NativeNameType.Type, "aiExportDataBlob const *")]
		public static AiExportDataBlob* ExportSceneToBlob([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFormatId, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				fixed (byte* ppFormatId = pFormatId)
				{
					AiExportDataBlob* ret = ExportSceneToBlobNative((AiScene*)ppScene, (byte*)ppFormatId, pPreprocessing);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Exports the given scene to a chosen file format. Returns the exported data as a binary blob which<br/>
		/// you can write into a file or something. When you're done with the data, use #aiReleaseExportBlob()<br/>
		/// to free the resources associated with the export.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiExportSceneToBlob")]
		[return: NativeName(NativeNameType.Type, "aiExportDataBlob const *")]
		public static AiExportDataBlob* ExportSceneToBlob([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFormatId")] [NativeName(NativeNameType.Type, "char const *")] string pFormatId, [NativeName(NativeNameType.Param, "pPreprocessing")] [NativeName(NativeNameType.Type, "unsigned int")] uint pPreprocessing)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pFormatId != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pFormatId);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pFormatId, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AiExportDataBlob* ret = ExportSceneToBlobNative((AiScene*)ppScene, pStr0, pPreprocessing);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Releases the memory associated with the given exported data. Use this function to free a data blob<br/>
		/// returned by aiExportScene().<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiReleaseExportBlob")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReleaseExportBlobNative([NativeName(NativeNameType.Param, "pData")] [NativeName(NativeNameType.Type, "aiExportDataBlob const *")] AiExportDataBlob* pData)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<AiExportDataBlob*, void>)funcTable[9])(pData);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[9])((nint)pData);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Releases the memory associated with the given exported data. Use this function to free a data blob<br/>
		/// returned by aiExportScene().<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiReleaseExportBlob")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseExportBlob([NativeName(NativeNameType.Param, "pData")] [NativeName(NativeNameType.Type, "aiExportDataBlob const *")] AiExportDataBlob* pData)
		{
			ReleaseExportBlobNative(pData);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Releases the memory associated with the given exported data. Use this function to free a data blob<br/>
		/// returned by aiExportScene().<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiReleaseExportBlob")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseExportBlob([NativeName(NativeNameType.Param, "pData")] [NativeName(NativeNameType.Type, "aiExportDataBlob const *")] ref AiExportDataBlob pData)
		{
			fixed (AiExportDataBlob* ppData = &pData)
			{
				ReleaseExportBlobNative((AiExportDataBlob*)ppData);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Reads the given file and returns its content.<br/>
		/// If the call succeeds, the imported data is returned in an aiScene structure.<br/>
		/// The data is intended to be read-only, it stays property of the ASSIMP<br/>
		/// library and will be stable until aiReleaseImport() is called. After you're<br/>
		/// done with it, call aiReleaseImport() to free the resources associated with<br/>
		/// this file. If the import fails, NULL is returned instead. Call<br/>
		/// aiGetErrorString() to retrieve a human-readable error text.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFile")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static AiScene* ImportFileNative([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] byte* pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, uint, AiScene*>)funcTable[10])(pFile, pFlags);
			#else
			return (AiScene*)((delegate* unmanaged[Cdecl]<nint, uint, nint>)funcTable[10])((nint)pFile, pFlags);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Reads the given file and returns its content.<br/>
		/// If the call succeeds, the imported data is returned in an aiScene structure.<br/>
		/// The data is intended to be read-only, it stays property of the ASSIMP<br/>
		/// library and will be stable until aiReleaseImport() is called. After you're<br/>
		/// done with it, call aiReleaseImport() to free the resources associated with<br/>
		/// this file. If the import fails, NULL is returned instead. Call<br/>
		/// aiGetErrorString() to retrieve a human-readable error text.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFile")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFile([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] byte* pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags)
		{
			AiScene* ret = ImportFileNative(pFile, pFlags);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Reads the given file and returns its content.<br/>
		/// If the call succeeds, the imported data is returned in an aiScene structure.<br/>
		/// The data is intended to be read-only, it stays property of the ASSIMP<br/>
		/// library and will be stable until aiReleaseImport() is called. After you're<br/>
		/// done with it, call aiReleaseImport() to free the resources associated with<br/>
		/// this file. If the import fails, NULL is returned instead. Call<br/>
		/// aiGetErrorString() to retrieve a human-readable error text.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFile")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFile([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags)
		{
			fixed (byte* ppFile = &pFile)
			{
				AiScene* ret = ImportFileNative((byte*)ppFile, pFlags);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Reads the given file and returns its content.<br/>
		/// If the call succeeds, the imported data is returned in an aiScene structure.<br/>
		/// The data is intended to be read-only, it stays property of the ASSIMP<br/>
		/// library and will be stable until aiReleaseImport() is called. After you're<br/>
		/// done with it, call aiReleaseImport() to free the resources associated with<br/>
		/// this file. If the import fails, NULL is returned instead. Call<br/>
		/// aiGetErrorString() to retrieve a human-readable error text.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFile")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFile([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags)
		{
			fixed (byte* ppFile = pFile)
			{
				AiScene* ret = ImportFileNative((byte*)ppFile, pFlags);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Reads the given file and returns its content.<br/>
		/// If the call succeeds, the imported data is returned in an aiScene structure.<br/>
		/// The data is intended to be read-only, it stays property of the ASSIMP<br/>
		/// library and will be stable until aiReleaseImport() is called. After you're<br/>
		/// done with it, call aiReleaseImport() to free the resources associated with<br/>
		/// this file. If the import fails, NULL is returned instead. Call<br/>
		/// aiGetErrorString() to retrieve a human-readable error text.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFile")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFile([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] string pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pFile != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pFile);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pFile, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AiScene* ret = ImportFileNative(pStr0, pFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Reads the given file using user-defined I/O functions and returns<br/>
		/// its content.<br/>
		/// If the call succeeds, the imported data is returned in an aiScene structure.<br/>
		/// The data is intended to be read-only, it stays property of the ASSIMP<br/>
		/// library and will be stable until aiReleaseImport() is called. After you're<br/>
		/// done with it, call aiReleaseImport() to free the resources associated with<br/>
		/// this file. If the import fails, NULL is returned instead. Call<br/>
		/// aiGetErrorString() to retrieve a human-readable error text.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileEx")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static AiScene* ImportFileExNative([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] byte* pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pFS")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* pfS)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, uint, AiFileIO*, AiScene*>)funcTable[11])(pFile, pFlags, pfS);
			#else
			return (AiScene*)((delegate* unmanaged[Cdecl]<nint, uint, nint, nint>)funcTable[11])((nint)pFile, pFlags, (nint)pfS);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Reads the given file using user-defined I/O functions and returns<br/>
		/// its content.<br/>
		/// If the call succeeds, the imported data is returned in an aiScene structure.<br/>
		/// The data is intended to be read-only, it stays property of the ASSIMP<br/>
		/// library and will be stable until aiReleaseImport() is called. After you're<br/>
		/// done with it, call aiReleaseImport() to free the resources associated with<br/>
		/// this file. If the import fails, NULL is returned instead. Call<br/>
		/// aiGetErrorString() to retrieve a human-readable error text.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileEx")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileEx([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] byte* pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pFS")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* pfS)
		{
			AiScene* ret = ImportFileExNative(pFile, pFlags, pfS);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Reads the given file using user-defined I/O functions and returns<br/>
		/// its content.<br/>
		/// If the call succeeds, the imported data is returned in an aiScene structure.<br/>
		/// The data is intended to be read-only, it stays property of the ASSIMP<br/>
		/// library and will be stable until aiReleaseImport() is called. After you're<br/>
		/// done with it, call aiReleaseImport() to free the resources associated with<br/>
		/// this file. If the import fails, NULL is returned instead. Call<br/>
		/// aiGetErrorString() to retrieve a human-readable error text.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileEx")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileEx([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pFS")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* pfS)
		{
			fixed (byte* ppFile = &pFile)
			{
				AiScene* ret = ImportFileExNative((byte*)ppFile, pFlags, pfS);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Reads the given file using user-defined I/O functions and returns<br/>
		/// its content.<br/>
		/// If the call succeeds, the imported data is returned in an aiScene structure.<br/>
		/// The data is intended to be read-only, it stays property of the ASSIMP<br/>
		/// library and will be stable until aiReleaseImport() is called. After you're<br/>
		/// done with it, call aiReleaseImport() to free the resources associated with<br/>
		/// this file. If the import fails, NULL is returned instead. Call<br/>
		/// aiGetErrorString() to retrieve a human-readable error text.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileEx")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileEx([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pFS")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* pfS)
		{
			fixed (byte* ppFile = pFile)
			{
				AiScene* ret = ImportFileExNative((byte*)ppFile, pFlags, pfS);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Reads the given file using user-defined I/O functions and returns<br/>
		/// its content.<br/>
		/// If the call succeeds, the imported data is returned in an aiScene structure.<br/>
		/// The data is intended to be read-only, it stays property of the ASSIMP<br/>
		/// library and will be stable until aiReleaseImport() is called. After you're<br/>
		/// done with it, call aiReleaseImport() to free the resources associated with<br/>
		/// this file. If the import fails, NULL is returned instead. Call<br/>
		/// aiGetErrorString() to retrieve a human-readable error text.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileEx")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileEx([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] string pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pFS")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* pfS)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pFile != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pFile);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pFile, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AiScene* ret = ImportFileExNative(pStr0, pFlags, pfS);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Reads the given file using user-defined I/O functions and returns<br/>
		/// its content.<br/>
		/// If the call succeeds, the imported data is returned in an aiScene structure.<br/>
		/// The data is intended to be read-only, it stays property of the ASSIMP<br/>
		/// library and will be stable until aiReleaseImport() is called. After you're<br/>
		/// done with it, call aiReleaseImport() to free the resources associated with<br/>
		/// this file. If the import fails, NULL is returned instead. Call<br/>
		/// aiGetErrorString() to retrieve a human-readable error text.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileEx")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileEx([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] byte* pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pFS")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO pfS)
		{
			fixed (AiFileIO* ppfS = &pfS)
			{
				AiScene* ret = ImportFileExNative(pFile, pFlags, (AiFileIO*)ppfS);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Reads the given file using user-defined I/O functions and returns<br/>
		/// its content.<br/>
		/// If the call succeeds, the imported data is returned in an aiScene structure.<br/>
		/// The data is intended to be read-only, it stays property of the ASSIMP<br/>
		/// library and will be stable until aiReleaseImport() is called. After you're<br/>
		/// done with it, call aiReleaseImport() to free the resources associated with<br/>
		/// this file. If the import fails, NULL is returned instead. Call<br/>
		/// aiGetErrorString() to retrieve a human-readable error text.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileEx")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileEx([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pFS")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO pfS)
		{
			fixed (byte* ppFile = &pFile)
			{
				fixed (AiFileIO* ppfS = &pfS)
				{
					AiScene* ret = ImportFileExNative((byte*)ppFile, pFlags, (AiFileIO*)ppfS);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Reads the given file using user-defined I/O functions and returns<br/>
		/// its content.<br/>
		/// If the call succeeds, the imported data is returned in an aiScene structure.<br/>
		/// The data is intended to be read-only, it stays property of the ASSIMP<br/>
		/// library and will be stable until aiReleaseImport() is called. After you're<br/>
		/// done with it, call aiReleaseImport() to free the resources associated with<br/>
		/// this file. If the import fails, NULL is returned instead. Call<br/>
		/// aiGetErrorString() to retrieve a human-readable error text.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileEx")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileEx([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pFS")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO pfS)
		{
			fixed (byte* ppFile = pFile)
			{
				fixed (AiFileIO* ppfS = &pfS)
				{
					AiScene* ret = ImportFileExNative((byte*)ppFile, pFlags, (AiFileIO*)ppfS);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Reads the given file using user-defined I/O functions and returns<br/>
		/// its content.<br/>
		/// If the call succeeds, the imported data is returned in an aiScene structure.<br/>
		/// The data is intended to be read-only, it stays property of the ASSIMP<br/>
		/// library and will be stable until aiReleaseImport() is called. After you're<br/>
		/// done with it, call aiReleaseImport() to free the resources associated with<br/>
		/// this file. If the import fails, NULL is returned instead. Call<br/>
		/// aiGetErrorString() to retrieve a human-readable error text.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileEx")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileEx([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] string pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pFS")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO pfS)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pFile != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pFile);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pFile, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (AiFileIO* ppfS = &pfS)
			{
				AiScene* ret = ImportFileExNative(pStr0, pFlags, (AiFileIO*)ppfS);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileEx, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileExWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static AiScene* ImportFileExWithPropertiesNative([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] byte* pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pFS")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* pfS, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] AiPropertyStore* pProps)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, uint, AiFileIO*, AiPropertyStore*, AiScene*>)funcTable[12])(pFile, pFlags, pfS, pProps);
			#else
			return (AiScene*)((delegate* unmanaged[Cdecl]<nint, uint, nint, nint, nint>)funcTable[12])((nint)pFile, pFlags, (nint)pfS, (nint)pProps);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileEx, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileExWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileExWithProperties([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] byte* pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pFS")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* pfS, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] AiPropertyStore* pProps)
		{
			AiScene* ret = ImportFileExWithPropertiesNative(pFile, pFlags, pfS, pProps);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileEx, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileExWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileExWithProperties([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pFS")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* pfS, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] AiPropertyStore* pProps)
		{
			fixed (byte* ppFile = &pFile)
			{
				AiScene* ret = ImportFileExWithPropertiesNative((byte*)ppFile, pFlags, pfS, pProps);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileEx, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileExWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileExWithProperties([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pFS")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* pfS, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] AiPropertyStore* pProps)
		{
			fixed (byte* ppFile = pFile)
			{
				AiScene* ret = ImportFileExWithPropertiesNative((byte*)ppFile, pFlags, pfS, pProps);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileEx, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileExWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileExWithProperties([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] string pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pFS")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* pfS, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] AiPropertyStore* pProps)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pFile != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pFile);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pFile, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AiScene* ret = ImportFileExWithPropertiesNative(pStr0, pFlags, pfS, pProps);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileEx, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileExWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileExWithProperties([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] byte* pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pFS")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO pfS, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] AiPropertyStore* pProps)
		{
			fixed (AiFileIO* ppfS = &pfS)
			{
				AiScene* ret = ImportFileExWithPropertiesNative(pFile, pFlags, (AiFileIO*)ppfS, pProps);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileEx, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileExWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileExWithProperties([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pFS")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO pfS, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] AiPropertyStore* pProps)
		{
			fixed (byte* ppFile = &pFile)
			{
				fixed (AiFileIO* ppfS = &pfS)
				{
					AiScene* ret = ImportFileExWithPropertiesNative((byte*)ppFile, pFlags, (AiFileIO*)ppfS, pProps);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileEx, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileExWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileExWithProperties([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pFS")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO pfS, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] AiPropertyStore* pProps)
		{
			fixed (byte* ppFile = pFile)
			{
				fixed (AiFileIO* ppfS = &pfS)
				{
					AiScene* ret = ImportFileExWithPropertiesNative((byte*)ppFile, pFlags, (AiFileIO*)ppfS, pProps);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileEx, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileExWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileExWithProperties([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] string pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pFS")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO pfS, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] AiPropertyStore* pProps)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pFile != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pFile);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pFile, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (AiFileIO* ppfS = &pfS)
			{
				AiScene* ret = ImportFileExWithPropertiesNative(pStr0, pFlags, (AiFileIO*)ppfS, pProps);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileEx, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileExWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileExWithProperties([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] byte* pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pFS")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* pfS, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] ref AiPropertyStore pProps)
		{
			fixed (AiPropertyStore* ppProps = &pProps)
			{
				AiScene* ret = ImportFileExWithPropertiesNative(pFile, pFlags, pfS, (AiPropertyStore*)ppProps);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileEx, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileExWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileExWithProperties([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pFS")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* pfS, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] ref AiPropertyStore pProps)
		{
			fixed (byte* ppFile = &pFile)
			{
				fixed (AiPropertyStore* ppProps = &pProps)
				{
					AiScene* ret = ImportFileExWithPropertiesNative((byte*)ppFile, pFlags, pfS, (AiPropertyStore*)ppProps);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileEx, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileExWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileExWithProperties([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pFS")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* pfS, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] ref AiPropertyStore pProps)
		{
			fixed (byte* ppFile = pFile)
			{
				fixed (AiPropertyStore* ppProps = &pProps)
				{
					AiScene* ret = ImportFileExWithPropertiesNative((byte*)ppFile, pFlags, pfS, (AiPropertyStore*)ppProps);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileEx, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileExWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileExWithProperties([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] string pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pFS")] [NativeName(NativeNameType.Type, "aiFileIO *")] AiFileIO* pfS, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] ref AiPropertyStore pProps)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pFile != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pFile);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pFile, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (AiPropertyStore* ppProps = &pProps)
			{
				AiScene* ret = ImportFileExWithPropertiesNative(pStr0, pFlags, pfS, (AiPropertyStore*)ppProps);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileEx, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileExWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileExWithProperties([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] byte* pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pFS")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO pfS, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] ref AiPropertyStore pProps)
		{
			fixed (AiFileIO* ppfS = &pfS)
			{
				fixed (AiPropertyStore* ppProps = &pProps)
				{
					AiScene* ret = ImportFileExWithPropertiesNative(pFile, pFlags, (AiFileIO*)ppfS, (AiPropertyStore*)ppProps);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileEx, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileExWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileExWithProperties([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] ref byte pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pFS")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO pfS, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] ref AiPropertyStore pProps)
		{
			fixed (byte* ppFile = &pFile)
			{
				fixed (AiFileIO* ppfS = &pfS)
				{
					fixed (AiPropertyStore* ppProps = &pProps)
					{
						AiScene* ret = ImportFileExWithPropertiesNative((byte*)ppFile, pFlags, (AiFileIO*)ppfS, (AiPropertyStore*)ppProps);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileEx, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileExWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileExWithProperties([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pFS")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO pfS, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] ref AiPropertyStore pProps)
		{
			fixed (byte* ppFile = pFile)
			{
				fixed (AiFileIO* ppfS = &pfS)
				{
					fixed (AiPropertyStore* ppProps = &pProps)
					{
						AiScene* ret = ImportFileExWithPropertiesNative((byte*)ppFile, pFlags, (AiFileIO*)ppfS, (AiPropertyStore*)ppProps);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileEx, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileExWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileExWithProperties([NativeName(NativeNameType.Param, "pFile")] [NativeName(NativeNameType.Type, "char const *")] string pFile, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pFS")] [NativeName(NativeNameType.Type, "aiFileIO *")] ref AiFileIO pfS, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] ref AiPropertyStore pProps)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pFile != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pFile);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pFile, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (AiFileIO* ppfS = &pfS)
			{
				fixed (AiPropertyStore* ppProps = &pProps)
				{
					AiScene* ret = ImportFileExWithPropertiesNative(pStr0, pFlags, (AiFileIO*)ppfS, (AiPropertyStore*)ppProps);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Reads the given file from a given memory buffer,<br/>
		/// If the call succeeds, the imported data is returned in an aiScene structure.<br/>
		/// The data is intended to be read-only, it stays property of the ASSIMP<br/>
		/// library and will be stable until aiReleaseImport() is called. After you're<br/>
		/// done with it, call aiReleaseImport() to free the resources associated with<br/>
		/// this file. If the import fails, NULL is returned.<br/>
		/// A human-readable error description can be retrieved by calling aiGetErrorString().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemory")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static AiScene* ImportFileFromMemoryNative([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] byte* pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] byte* pHint)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, uint, uint, byte*, AiScene*>)funcTable[13])(pBuffer, pLength, pFlags, pHint);
			#else
			return (AiScene*)((delegate* unmanaged[Cdecl]<nint, uint, uint, nint, nint>)funcTable[13])((nint)pBuffer, pLength, pFlags, (nint)pHint);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Reads the given file from a given memory buffer,<br/>
		/// If the call succeeds, the imported data is returned in an aiScene structure.<br/>
		/// The data is intended to be read-only, it stays property of the ASSIMP<br/>
		/// library and will be stable until aiReleaseImport() is called. After you're<br/>
		/// done with it, call aiReleaseImport() to free the resources associated with<br/>
		/// this file. If the import fails, NULL is returned.<br/>
		/// A human-readable error description can be retrieved by calling aiGetErrorString().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemory")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemory([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] byte* pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] byte* pHint)
		{
			AiScene* ret = ImportFileFromMemoryNative(pBuffer, pLength, pFlags, pHint);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Reads the given file from a given memory buffer,<br/>
		/// If the call succeeds, the imported data is returned in an aiScene structure.<br/>
		/// The data is intended to be read-only, it stays property of the ASSIMP<br/>
		/// library and will be stable until aiReleaseImport() is called. After you're<br/>
		/// done with it, call aiReleaseImport() to free the resources associated with<br/>
		/// this file. If the import fails, NULL is returned.<br/>
		/// A human-readable error description can be retrieved by calling aiGetErrorString().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemory")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemory([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] ref byte pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] byte* pHint)
		{
			fixed (byte* ppBuffer = &pBuffer)
			{
				AiScene* ret = ImportFileFromMemoryNative((byte*)ppBuffer, pLength, pFlags, pHint);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Reads the given file from a given memory buffer,<br/>
		/// If the call succeeds, the imported data is returned in an aiScene structure.<br/>
		/// The data is intended to be read-only, it stays property of the ASSIMP<br/>
		/// library and will be stable until aiReleaseImport() is called. After you're<br/>
		/// done with it, call aiReleaseImport() to free the resources associated with<br/>
		/// this file. If the import fails, NULL is returned.<br/>
		/// A human-readable error description can be retrieved by calling aiGetErrorString().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemory")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemory([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] byte* pHint)
		{
			fixed (byte* ppBuffer = pBuffer)
			{
				AiScene* ret = ImportFileFromMemoryNative((byte*)ppBuffer, pLength, pFlags, pHint);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Reads the given file from a given memory buffer,<br/>
		/// If the call succeeds, the imported data is returned in an aiScene structure.<br/>
		/// The data is intended to be read-only, it stays property of the ASSIMP<br/>
		/// library and will be stable until aiReleaseImport() is called. After you're<br/>
		/// done with it, call aiReleaseImport() to free the resources associated with<br/>
		/// this file. If the import fails, NULL is returned.<br/>
		/// A human-readable error description can be retrieved by calling aiGetErrorString().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemory")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemory([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] string pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] byte* pHint)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pBuffer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pBuffer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pBuffer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AiScene* ret = ImportFileFromMemoryNative(pStr0, pLength, pFlags, pHint);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Reads the given file from a given memory buffer,<br/>
		/// If the call succeeds, the imported data is returned in an aiScene structure.<br/>
		/// The data is intended to be read-only, it stays property of the ASSIMP<br/>
		/// library and will be stable until aiReleaseImport() is called. After you're<br/>
		/// done with it, call aiReleaseImport() to free the resources associated with<br/>
		/// this file. If the import fails, NULL is returned.<br/>
		/// A human-readable error description can be retrieved by calling aiGetErrorString().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemory")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemory([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] byte* pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] ref byte pHint)
		{
			fixed (byte* ppHint = &pHint)
			{
				AiScene* ret = ImportFileFromMemoryNative(pBuffer, pLength, pFlags, (byte*)ppHint);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Reads the given file from a given memory buffer,<br/>
		/// If the call succeeds, the imported data is returned in an aiScene structure.<br/>
		/// The data is intended to be read-only, it stays property of the ASSIMP<br/>
		/// library and will be stable until aiReleaseImport() is called. After you're<br/>
		/// done with it, call aiReleaseImport() to free the resources associated with<br/>
		/// this file. If the import fails, NULL is returned.<br/>
		/// A human-readable error description can be retrieved by calling aiGetErrorString().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemory")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemory([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] byte* pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pHint)
		{
			fixed (byte* ppHint = pHint)
			{
				AiScene* ret = ImportFileFromMemoryNative(pBuffer, pLength, pFlags, (byte*)ppHint);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Reads the given file from a given memory buffer,<br/>
		/// If the call succeeds, the imported data is returned in an aiScene structure.<br/>
		/// The data is intended to be read-only, it stays property of the ASSIMP<br/>
		/// library and will be stable until aiReleaseImport() is called. After you're<br/>
		/// done with it, call aiReleaseImport() to free the resources associated with<br/>
		/// this file. If the import fails, NULL is returned.<br/>
		/// A human-readable error description can be retrieved by calling aiGetErrorString().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemory")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemory([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] byte* pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] string pHint)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pHint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pHint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pHint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AiScene* ret = ImportFileFromMemoryNative(pBuffer, pLength, pFlags, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Reads the given file from a given memory buffer,<br/>
		/// If the call succeeds, the imported data is returned in an aiScene structure.<br/>
		/// The data is intended to be read-only, it stays property of the ASSIMP<br/>
		/// library and will be stable until aiReleaseImport() is called. After you're<br/>
		/// done with it, call aiReleaseImport() to free the resources associated with<br/>
		/// this file. If the import fails, NULL is returned.<br/>
		/// A human-readable error description can be retrieved by calling aiGetErrorString().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemory")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemory([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] ref byte pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] ref byte pHint)
		{
			fixed (byte* ppBuffer = &pBuffer)
			{
				fixed (byte* ppHint = &pHint)
				{
					AiScene* ret = ImportFileFromMemoryNative((byte*)ppBuffer, pLength, pFlags, (byte*)ppHint);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Reads the given file from a given memory buffer,<br/>
		/// If the call succeeds, the imported data is returned in an aiScene structure.<br/>
		/// The data is intended to be read-only, it stays property of the ASSIMP<br/>
		/// library and will be stable until aiReleaseImport() is called. After you're<br/>
		/// done with it, call aiReleaseImport() to free the resources associated with<br/>
		/// this file. If the import fails, NULL is returned.<br/>
		/// A human-readable error description can be retrieved by calling aiGetErrorString().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemory")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemory([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pHint)
		{
			fixed (byte* ppBuffer = pBuffer)
			{
				fixed (byte* ppHint = pHint)
				{
					AiScene* ret = ImportFileFromMemoryNative((byte*)ppBuffer, pLength, pFlags, (byte*)ppHint);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Reads the given file from a given memory buffer,<br/>
		/// If the call succeeds, the imported data is returned in an aiScene structure.<br/>
		/// The data is intended to be read-only, it stays property of the ASSIMP<br/>
		/// library and will be stable until aiReleaseImport() is called. After you're<br/>
		/// done with it, call aiReleaseImport() to free the resources associated with<br/>
		/// this file. If the import fails, NULL is returned.<br/>
		/// A human-readable error description can be retrieved by calling aiGetErrorString().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemory")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemory([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] string pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] string pHint)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pBuffer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pBuffer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pBuffer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (pHint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(pHint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(pHint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			AiScene* ret = ImportFileFromMemoryNative(pStr0, pLength, pFlags, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemoryWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static AiScene* ImportFileFromMemoryWithPropertiesNative([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] byte* pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] byte* pHint, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] AiPropertyStore* pProps)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, uint, uint, byte*, AiPropertyStore*, AiScene*>)funcTable[14])(pBuffer, pLength, pFlags, pHint, pProps);
			#else
			return (AiScene*)((delegate* unmanaged[Cdecl]<nint, uint, uint, nint, nint, nint>)funcTable[14])((nint)pBuffer, pLength, pFlags, (nint)pHint, (nint)pProps);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemoryWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemoryWithProperties([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] byte* pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] byte* pHint, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] AiPropertyStore* pProps)
		{
			AiScene* ret = ImportFileFromMemoryWithPropertiesNative(pBuffer, pLength, pFlags, pHint, pProps);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemoryWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemoryWithProperties([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] ref byte pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] byte* pHint, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] AiPropertyStore* pProps)
		{
			fixed (byte* ppBuffer = &pBuffer)
			{
				AiScene* ret = ImportFileFromMemoryWithPropertiesNative((byte*)ppBuffer, pLength, pFlags, pHint, pProps);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemoryWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemoryWithProperties([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] byte* pHint, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] AiPropertyStore* pProps)
		{
			fixed (byte* ppBuffer = pBuffer)
			{
				AiScene* ret = ImportFileFromMemoryWithPropertiesNative((byte*)ppBuffer, pLength, pFlags, pHint, pProps);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemoryWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemoryWithProperties([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] string pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] byte* pHint, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] AiPropertyStore* pProps)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pBuffer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pBuffer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pBuffer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AiScene* ret = ImportFileFromMemoryWithPropertiesNative(pStr0, pLength, pFlags, pHint, pProps);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemoryWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemoryWithProperties([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] byte* pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] ref byte pHint, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] AiPropertyStore* pProps)
		{
			fixed (byte* ppHint = &pHint)
			{
				AiScene* ret = ImportFileFromMemoryWithPropertiesNative(pBuffer, pLength, pFlags, (byte*)ppHint, pProps);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemoryWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemoryWithProperties([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] byte* pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pHint, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] AiPropertyStore* pProps)
		{
			fixed (byte* ppHint = pHint)
			{
				AiScene* ret = ImportFileFromMemoryWithPropertiesNative(pBuffer, pLength, pFlags, (byte*)ppHint, pProps);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemoryWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemoryWithProperties([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] byte* pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] string pHint, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] AiPropertyStore* pProps)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pHint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pHint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pHint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AiScene* ret = ImportFileFromMemoryWithPropertiesNative(pBuffer, pLength, pFlags, pStr0, pProps);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemoryWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemoryWithProperties([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] ref byte pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] ref byte pHint, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] AiPropertyStore* pProps)
		{
			fixed (byte* ppBuffer = &pBuffer)
			{
				fixed (byte* ppHint = &pHint)
				{
					AiScene* ret = ImportFileFromMemoryWithPropertiesNative((byte*)ppBuffer, pLength, pFlags, (byte*)ppHint, pProps);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemoryWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemoryWithProperties([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pHint, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] AiPropertyStore* pProps)
		{
			fixed (byte* ppBuffer = pBuffer)
			{
				fixed (byte* ppHint = pHint)
				{
					AiScene* ret = ImportFileFromMemoryWithPropertiesNative((byte*)ppBuffer, pLength, pFlags, (byte*)ppHint, pProps);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemoryWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemoryWithProperties([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] string pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] string pHint, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] AiPropertyStore* pProps)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pBuffer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pBuffer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pBuffer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (pHint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(pHint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(pHint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			AiScene* ret = ImportFileFromMemoryWithPropertiesNative(pStr0, pLength, pFlags, pStr1, pProps);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemoryWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemoryWithProperties([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] byte* pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] byte* pHint, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] ref AiPropertyStore pProps)
		{
			fixed (AiPropertyStore* ppProps = &pProps)
			{
				AiScene* ret = ImportFileFromMemoryWithPropertiesNative(pBuffer, pLength, pFlags, pHint, (AiPropertyStore*)ppProps);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemoryWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemoryWithProperties([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] ref byte pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] byte* pHint, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] ref AiPropertyStore pProps)
		{
			fixed (byte* ppBuffer = &pBuffer)
			{
				fixed (AiPropertyStore* ppProps = &pProps)
				{
					AiScene* ret = ImportFileFromMemoryWithPropertiesNative((byte*)ppBuffer, pLength, pFlags, pHint, (AiPropertyStore*)ppProps);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemoryWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemoryWithProperties([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] byte* pHint, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] ref AiPropertyStore pProps)
		{
			fixed (byte* ppBuffer = pBuffer)
			{
				fixed (AiPropertyStore* ppProps = &pProps)
				{
					AiScene* ret = ImportFileFromMemoryWithPropertiesNative((byte*)ppBuffer, pLength, pFlags, pHint, (AiPropertyStore*)ppProps);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemoryWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemoryWithProperties([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] string pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] byte* pHint, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] ref AiPropertyStore pProps)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pBuffer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pBuffer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pBuffer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (AiPropertyStore* ppProps = &pProps)
			{
				AiScene* ret = ImportFileFromMemoryWithPropertiesNative(pStr0, pLength, pFlags, pHint, (AiPropertyStore*)ppProps);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemoryWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemoryWithProperties([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] byte* pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] ref byte pHint, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] ref AiPropertyStore pProps)
		{
			fixed (byte* ppHint = &pHint)
			{
				fixed (AiPropertyStore* ppProps = &pProps)
				{
					AiScene* ret = ImportFileFromMemoryWithPropertiesNative(pBuffer, pLength, pFlags, (byte*)ppHint, (AiPropertyStore*)ppProps);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemoryWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemoryWithProperties([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] byte* pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pHint, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] ref AiPropertyStore pProps)
		{
			fixed (byte* ppHint = pHint)
			{
				fixed (AiPropertyStore* ppProps = &pProps)
				{
					AiScene* ret = ImportFileFromMemoryWithPropertiesNative(pBuffer, pLength, pFlags, (byte*)ppHint, (AiPropertyStore*)ppProps);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemoryWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemoryWithProperties([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] byte* pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] string pHint, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] ref AiPropertyStore pProps)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pHint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pHint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pHint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (AiPropertyStore* ppProps = &pProps)
			{
				AiScene* ret = ImportFileFromMemoryWithPropertiesNative(pBuffer, pLength, pFlags, pStr0, (AiPropertyStore*)ppProps);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemoryWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemoryWithProperties([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] ref byte pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] ref byte pHint, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] ref AiPropertyStore pProps)
		{
			fixed (byte* ppBuffer = &pBuffer)
			{
				fixed (byte* ppHint = &pHint)
				{
					fixed (AiPropertyStore* ppProps = &pProps)
					{
						AiScene* ret = ImportFileFromMemoryWithPropertiesNative((byte*)ppBuffer, pLength, pFlags, (byte*)ppHint, (AiPropertyStore*)ppProps);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemoryWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemoryWithProperties([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pHint, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] ref AiPropertyStore pProps)
		{
			fixed (byte* ppBuffer = pBuffer)
			{
				fixed (byte* ppHint = pHint)
				{
					fixed (AiPropertyStore* ppProps = &pProps)
					{
						AiScene* ret = ImportFileFromMemoryWithPropertiesNative((byte*)ppBuffer, pLength, pFlags, (byte*)ppHint, (AiPropertyStore*)ppProps);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiImportFileFromMemoryWithProperties")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ImportFileFromMemoryWithProperties([NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "char const *")] string pBuffer, [NativeName(NativeNameType.Param, "pLength")] [NativeName(NativeNameType.Type, "unsigned int")] uint pLength, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags, [NativeName(NativeNameType.Param, "pHint")] [NativeName(NativeNameType.Type, "char const *")] string pHint, [NativeName(NativeNameType.Param, "pProps")] [NativeName(NativeNameType.Type, "aiPropertyStore const *")] ref AiPropertyStore pProps)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pBuffer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pBuffer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pBuffer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (pHint != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(pHint);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(pHint, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (AiPropertyStore* ppProps = &pProps)
			{
				AiScene* ret = ImportFileFromMemoryWithPropertiesNative(pStr0, pLength, pFlags, pStr1, (AiPropertyStore*)ppProps);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Apply post-processing to an already-imported scene.<br/>
		/// This is strictly equivalent to calling #aiImportFile()/#aiImportFileEx with the<br/>
		/// same flags. However, you can use this separate function to inspect the imported<br/>
		/// scene first to fine-tune your post-processing setup.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiApplyPostProcessing")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static AiScene* ApplyPostProcessingNative([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<AiScene*, uint, AiScene*>)funcTable[15])(pScene, pFlags);
			#else
			return (AiScene*)((delegate* unmanaged[Cdecl]<nint, uint, nint>)funcTable[15])((nint)pScene, pFlags);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Apply post-processing to an already-imported scene.<br/>
		/// This is strictly equivalent to calling #aiImportFile()/#aiImportFileEx with the<br/>
		/// same flags. However, you can use this separate function to inspect the imported<br/>
		/// scene first to fine-tune your post-processing setup.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiApplyPostProcessing")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ApplyPostProcessing([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags)
		{
			AiScene* ret = ApplyPostProcessingNative(pScene, pFlags);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Apply post-processing to an already-imported scene.<br/>
		/// This is strictly equivalent to calling #aiImportFile()/#aiImportFileEx with the<br/>
		/// same flags. However, you can use this separate function to inspect the imported<br/>
		/// scene first to fine-tune your post-processing setup.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiApplyPostProcessing")]
		[return: NativeName(NativeNameType.Type, "aiScene const *")]
		public static AiScene* ApplyPostProcessing([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "unsigned int")] uint pFlags)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				AiScene* ret = ApplyPostProcessingNative((AiScene*)ppScene, pFlags);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get one of the predefine log streams. This is the quick'n'easy solution to<br/>
		/// access Assimp's log system. Attaching a log stream can slightly reduce Assimp's<br/>
		/// overall import performance.<br/>
		/// Usage is rather simple (this will stream the log to a file, named log.txt, and<br/>
		/// the stdout stream of the process:<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetPredefinedLogStream")]
		[return: NativeName(NativeNameType.Type, "aiLogStream")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static AiLogStream GetPredefinedLogStreamNative([NativeName(NativeNameType.Param, "pStreams")] [NativeName(NativeNameType.Type, "aiDefaultLogStream")] AiDefaultLogStream pStreams, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<AiDefaultLogStream, byte*, AiLogStream>)funcTable[16])(pStreams, file);
			#else
			return (AiLogStream)((delegate* unmanaged[Cdecl]<AiDefaultLogStream, nint, AiLogStream>)funcTable[16])(pStreams, (nint)file);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get one of the predefine log streams. This is the quick'n'easy solution to<br/>
		/// access Assimp's log system. Attaching a log stream can slightly reduce Assimp's<br/>
		/// overall import performance.<br/>
		/// Usage is rather simple (this will stream the log to a file, named log.txt, and<br/>
		/// the stdout stream of the process:<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetPredefinedLogStream")]
		[return: NativeName(NativeNameType.Type, "aiLogStream")]
		public static AiLogStream GetPredefinedLogStream([NativeName(NativeNameType.Param, "pStreams")] [NativeName(NativeNameType.Type, "aiDefaultLogStream")] AiDefaultLogStream pStreams, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			AiLogStream ret = GetPredefinedLogStreamNative(pStreams, file);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get one of the predefine log streams. This is the quick'n'easy solution to<br/>
		/// access Assimp's log system. Attaching a log stream can slightly reduce Assimp's<br/>
		/// overall import performance.<br/>
		/// Usage is rather simple (this will stream the log to a file, named log.txt, and<br/>
		/// the stdout stream of the process:<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetPredefinedLogStream")]
		[return: NativeName(NativeNameType.Type, "aiLogStream")]
		public static AiLogStream GetPredefinedLogStream([NativeName(NativeNameType.Param, "pStreams")] [NativeName(NativeNameType.Type, "aiDefaultLogStream")] AiDefaultLogStream pStreams, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file)
		{
			fixed (byte* pfile = &file)
			{
				AiLogStream ret = GetPredefinedLogStreamNative(pStreams, (byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get one of the predefine log streams. This is the quick'n'easy solution to<br/>
		/// access Assimp's log system. Attaching a log stream can slightly reduce Assimp's<br/>
		/// overall import performance.<br/>
		/// Usage is rather simple (this will stream the log to a file, named log.txt, and<br/>
		/// the stdout stream of the process:<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetPredefinedLogStream")]
		[return: NativeName(NativeNameType.Type, "aiLogStream")]
		public static AiLogStream GetPredefinedLogStream([NativeName(NativeNameType.Param, "pStreams")] [NativeName(NativeNameType.Type, "aiDefaultLogStream")] AiDefaultLogStream pStreams, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file)
		{
			fixed (byte* pfile = file)
			{
				AiLogStream ret = GetPredefinedLogStreamNative(pStreams, (byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get one of the predefine log streams. This is the quick'n'easy solution to<br/>
		/// access Assimp's log system. Attaching a log stream can slightly reduce Assimp's<br/>
		/// overall import performance.<br/>
		/// Usage is rather simple (this will stream the log to a file, named log.txt, and<br/>
		/// the stdout stream of the process:<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetPredefinedLogStream")]
		[return: NativeName(NativeNameType.Type, "aiLogStream")]
		public static AiLogStream GetPredefinedLogStream([NativeName(NativeNameType.Param, "pStreams")] [NativeName(NativeNameType.Type, "aiDefaultLogStream")] AiDefaultLogStream pStreams, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AiLogStream ret = GetPredefinedLogStreamNative(pStreams, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Attach a custom log stream to the libraries' logging system.<br/>
		/// Attaching a log stream can slightly reduce Assimp's overall import<br/>
		/// performance. Multiple log-streams can be attached.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiAttachLogStream")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AttachLogStreamNative([NativeName(NativeNameType.Param, "stream")] [NativeName(NativeNameType.Type, "aiLogStream const *")] AiLogStream* stream)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<AiLogStream*, void>)funcTable[17])(stream);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[17])((nint)stream);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Attach a custom log stream to the libraries' logging system.<br/>
		/// Attaching a log stream can slightly reduce Assimp's overall import<br/>
		/// performance. Multiple log-streams can be attached.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiAttachLogStream")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AttachLogStream([NativeName(NativeNameType.Param, "stream")] [NativeName(NativeNameType.Type, "aiLogStream const *")] AiLogStream* stream)
		{
			AttachLogStreamNative(stream);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Attach a custom log stream to the libraries' logging system.<br/>
		/// Attaching a log stream can slightly reduce Assimp's overall import<br/>
		/// performance. Multiple log-streams can be attached.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiAttachLogStream")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AttachLogStream([NativeName(NativeNameType.Param, "stream")] [NativeName(NativeNameType.Type, "aiLogStream const *")] ref AiLogStream stream)
		{
			fixed (AiLogStream* pstream = &stream)
			{
				AttachLogStreamNative((AiLogStream*)pstream);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Enable verbose logging. Verbose logging includes debug-related stuff and<br/>
		/// detailed import statistics. This can have severe impact on import performance<br/>
		/// and memory consumption. However, it might be useful to find out why a file<br/>
		/// didn't read correctly.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiEnableVerboseLogging")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableVerboseLoggingNative([NativeName(NativeNameType.Param, "d")] [NativeName(NativeNameType.Type, "aiBool")] int d)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[18])(d);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[18])(d);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Enable verbose logging. Verbose logging includes debug-related stuff and<br/>
		/// detailed import statistics. This can have severe impact on import performance<br/>
		/// and memory consumption. However, it might be useful to find out why a file<br/>
		/// didn't read correctly.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiEnableVerboseLogging")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EnableVerboseLogging([NativeName(NativeNameType.Param, "d")] [NativeName(NativeNameType.Type, "aiBool")] int d)
		{
			EnableVerboseLoggingNative(d);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Detach a custom log stream from the libraries' logging system.<br/>
		/// This is the counterpart of #aiAttachLogStream. If you attached a stream,<br/>
		/// don't forget to detach it again.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiDetachLogStream")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static AiReturn DetachLogStreamNative([NativeName(NativeNameType.Param, "stream")] [NativeName(NativeNameType.Type, "aiLogStream const *")] AiLogStream* stream)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<AiLogStream*, AiReturn>)funcTable[19])(stream);
			#else
			return (AiReturn)((delegate* unmanaged[Cdecl]<nint, AiReturn>)funcTable[19])((nint)stream);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Detach a custom log stream from the libraries' logging system.<br/>
		/// This is the counterpart of #aiAttachLogStream. If you attached a stream,<br/>
		/// don't forget to detach it again.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiDetachLogStream")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn DetachLogStream([NativeName(NativeNameType.Param, "stream")] [NativeName(NativeNameType.Type, "aiLogStream const *")] AiLogStream* stream)
		{
			AiReturn ret = DetachLogStreamNative(stream);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Detach a custom log stream from the libraries' logging system.<br/>
		/// This is the counterpart of #aiAttachLogStream. If you attached a stream,<br/>
		/// don't forget to detach it again.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiDetachLogStream")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn DetachLogStream([NativeName(NativeNameType.Param, "stream")] [NativeName(NativeNameType.Type, "aiLogStream const *")] ref AiLogStream stream)
		{
			fixed (AiLogStream* pstream = &stream)
			{
				AiReturn ret = DetachLogStreamNative((AiLogStream*)pstream);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Detach all active log streams from the libraries' logging system.<br/>
		/// This ensures that the logging system is terminated properly and all<br/>
		/// resources allocated by it are actually freed. If you attached a stream,<br/>
		/// don't forget to detach it again.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiDetachAllLogStreams")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DetachAllLogStreamsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[20])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[20])();
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Detach all active log streams from the libraries' logging system.<br/>
		/// This ensures that the logging system is terminated properly and all<br/>
		/// resources allocated by it are actually freed. If you attached a stream,<br/>
		/// don't forget to detach it again.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiDetachAllLogStreams")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DetachAllLogStreams()
		{
			DetachAllLogStreamsNative();
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Releases all resources associated with the given import process.<br/>
		/// Call this function after you're done with the imported data.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiReleaseImport")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReleaseImportNative([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<AiScene*, void>)funcTable[21])(pScene);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[21])((nint)pScene);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Releases all resources associated with the given import process.<br/>
		/// Call this function after you're done with the imported data.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiReleaseImport")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseImport([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pScene)
		{
			ReleaseImportNative(pScene);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Releases all resources associated with the given import process.<br/>
		/// Call this function after you're done with the imported data.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiReleaseImport")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseImport([NativeName(NativeNameType.Param, "pScene")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pScene)
		{
			fixed (AiScene* ppScene = &pScene)
			{
				ReleaseImportNative((AiScene*)ppScene);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns the error text of the last failed import process.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetErrorString")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetErrorStringNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[22])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[22])();
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns the error text of the last failed import process.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetErrorString")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetErrorString()
		{
			byte* ret = GetErrorStringNative();
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns the error text of the last failed import process.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetErrorString")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetErrorStringS()
		{
			string ret = Utils.DecodeStringUTF8(GetErrorStringNative());
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns whether a given file extension is supported by ASSIMP<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiIsExtensionSupported")]
		[return: NativeName(NativeNameType.Type, "aiBool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsExtensionSupportedNative([NativeName(NativeNameType.Param, "szExtension")] [NativeName(NativeNameType.Type, "char const *")] byte* szExtension)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[23])(szExtension);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[23])((nint)szExtension);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns whether a given file extension is supported by ASSIMP<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiIsExtensionSupported")]
		[return: NativeName(NativeNameType.Type, "aiBool")]
		public static int IsExtensionSupported([NativeName(NativeNameType.Param, "szExtension")] [NativeName(NativeNameType.Type, "char const *")] byte* szExtension)
		{
			int ret = IsExtensionSupportedNative(szExtension);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns whether a given file extension is supported by ASSIMP<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiIsExtensionSupported")]
		[return: NativeName(NativeNameType.Type, "aiBool")]
		public static int IsExtensionSupported([NativeName(NativeNameType.Param, "szExtension")] [NativeName(NativeNameType.Type, "char const *")] ref byte szExtension)
		{
			fixed (byte* pszExtension = &szExtension)
			{
				int ret = IsExtensionSupportedNative((byte*)pszExtension);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns whether a given file extension is supported by ASSIMP<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiIsExtensionSupported")]
		[return: NativeName(NativeNameType.Type, "aiBool")]
		public static int IsExtensionSupported([NativeName(NativeNameType.Param, "szExtension")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> szExtension)
		{
			fixed (byte* pszExtension = szExtension)
			{
				int ret = IsExtensionSupportedNative((byte*)pszExtension);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns whether a given file extension is supported by ASSIMP<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiIsExtensionSupported")]
		[return: NativeName(NativeNameType.Type, "aiBool")]
		public static int IsExtensionSupported([NativeName(NativeNameType.Param, "szExtension")] [NativeName(NativeNameType.Type, "char const *")] string szExtension)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (szExtension != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(szExtension);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(szExtension, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = IsExtensionSupportedNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a list of all file extensions supported by ASSIMP.<br/>
		/// If a file extension is contained in the list this does, of course, not<br/>
		/// mean that ASSIMP is able to load all files with this extension.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetExtensionList")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetExtensionListNative([NativeName(NativeNameType.Param, "szOut")] [NativeName(NativeNameType.Type, "aiString *")] AiString* szOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<AiString*, void>)funcTable[24])(szOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[24])((nint)szOut);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a list of all file extensions supported by ASSIMP.<br/>
		/// If a file extension is contained in the list this does, of course, not<br/>
		/// mean that ASSIMP is able to load all files with this extension.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetExtensionList")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetExtensionList([NativeName(NativeNameType.Param, "szOut")] [NativeName(NativeNameType.Type, "aiString *")] AiString* szOut)
		{
			GetExtensionListNative(szOut);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a list of all file extensions supported by ASSIMP.<br/>
		/// If a file extension is contained in the list this does, of course, not<br/>
		/// mean that ASSIMP is able to load all files with this extension.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetExtensionList")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetExtensionList([NativeName(NativeNameType.Param, "szOut")] [NativeName(NativeNameType.Type, "aiString *")] ref AiString szOut)
		{
			fixed (AiString* pszOut = &szOut)
			{
				GetExtensionListNative((AiString*)pszOut);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the approximated storage required by an imported asset<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMemoryRequirements")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMemoryRequirementsNative([NativeName(NativeNameType.Param, "pIn")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pIn, [NativeName(NativeNameType.Param, "in")] [NativeName(NativeNameType.Type, "aiMemoryInfo *")] AiMemoryInfo* input)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<AiScene*, AiMemoryInfo*, void>)funcTable[25])(pIn, input);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[25])((nint)pIn, (nint)input);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the approximated storage required by an imported asset<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMemoryRequirements")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetMemoryRequirements([NativeName(NativeNameType.Param, "pIn")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pIn, [NativeName(NativeNameType.Param, "in")] [NativeName(NativeNameType.Type, "aiMemoryInfo *")] AiMemoryInfo* input)
		{
			GetMemoryRequirementsNative(pIn, input);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the approximated storage required by an imported asset<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMemoryRequirements")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetMemoryRequirements([NativeName(NativeNameType.Param, "pIn")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pIn, [NativeName(NativeNameType.Param, "in")] [NativeName(NativeNameType.Type, "aiMemoryInfo *")] AiMemoryInfo* input)
		{
			fixed (AiScene* ppIn = &pIn)
			{
				GetMemoryRequirementsNative((AiScene*)ppIn, input);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the approximated storage required by an imported asset<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMemoryRequirements")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetMemoryRequirements([NativeName(NativeNameType.Param, "pIn")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pIn, [NativeName(NativeNameType.Param, "in")] [NativeName(NativeNameType.Type, "aiMemoryInfo *")] ref AiMemoryInfo input)
		{
			fixed (AiMemoryInfo* pinput = &input)
			{
				GetMemoryRequirementsNative(pIn, (AiMemoryInfo*)pinput);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the approximated storage required by an imported asset<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMemoryRequirements")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetMemoryRequirements([NativeName(NativeNameType.Param, "pIn")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pIn, [NativeName(NativeNameType.Param, "in")] [NativeName(NativeNameType.Type, "aiMemoryInfo *")] ref AiMemoryInfo input)
		{
			fixed (AiScene* ppIn = &pIn)
			{
				fixed (AiMemoryInfo* pinput = &input)
				{
					GetMemoryRequirementsNative((AiScene*)ppIn, (AiMemoryInfo*)pinput);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns an embedded texture, or nullptr.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetEmbeddedTexture")]
		[return: NativeName(NativeNameType.Type, "aiTexture const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static AiTexture* GetEmbeddedTextureNative([NativeName(NativeNameType.Param, "pIn")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pIn, [NativeName(NativeNameType.Param, "filename")] [NativeName(NativeNameType.Type, "char const *")] byte* filename)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<AiScene*, byte*, AiTexture*>)funcTable[26])(pIn, filename);
			#else
			return (AiTexture*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[26])((nint)pIn, (nint)filename);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns an embedded texture, or nullptr.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetEmbeddedTexture")]
		[return: NativeName(NativeNameType.Type, "aiTexture const *")]
		public static AiTexture* GetEmbeddedTexture([NativeName(NativeNameType.Param, "pIn")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pIn, [NativeName(NativeNameType.Param, "filename")] [NativeName(NativeNameType.Type, "char const *")] byte* filename)
		{
			AiTexture* ret = GetEmbeddedTextureNative(pIn, filename);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns an embedded texture, or nullptr.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetEmbeddedTexture")]
		[return: NativeName(NativeNameType.Type, "aiTexture const *")]
		public static AiTexture* GetEmbeddedTexture([NativeName(NativeNameType.Param, "pIn")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pIn, [NativeName(NativeNameType.Param, "filename")] [NativeName(NativeNameType.Type, "char const *")] byte* filename)
		{
			fixed (AiScene* ppIn = &pIn)
			{
				AiTexture* ret = GetEmbeddedTextureNative((AiScene*)ppIn, filename);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns an embedded texture, or nullptr.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetEmbeddedTexture")]
		[return: NativeName(NativeNameType.Type, "aiTexture const *")]
		public static AiTexture* GetEmbeddedTexture([NativeName(NativeNameType.Param, "pIn")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pIn, [NativeName(NativeNameType.Param, "filename")] [NativeName(NativeNameType.Type, "char const *")] ref byte filename)
		{
			fixed (byte* pfilename = &filename)
			{
				AiTexture* ret = GetEmbeddedTextureNative(pIn, (byte*)pfilename);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns an embedded texture, or nullptr.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetEmbeddedTexture")]
		[return: NativeName(NativeNameType.Type, "aiTexture const *")]
		public static AiTexture* GetEmbeddedTexture([NativeName(NativeNameType.Param, "pIn")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pIn, [NativeName(NativeNameType.Param, "filename")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> filename)
		{
			fixed (byte* pfilename = filename)
			{
				AiTexture* ret = GetEmbeddedTextureNative(pIn, (byte*)pfilename);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns an embedded texture, or nullptr.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetEmbeddedTexture")]
		[return: NativeName(NativeNameType.Type, "aiTexture const *")]
		public static AiTexture* GetEmbeddedTexture([NativeName(NativeNameType.Param, "pIn")] [NativeName(NativeNameType.Type, "aiScene const *")] AiScene* pIn, [NativeName(NativeNameType.Param, "filename")] [NativeName(NativeNameType.Type, "char const *")] string filename)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AiTexture* ret = GetEmbeddedTextureNative(pIn, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns an embedded texture, or nullptr.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetEmbeddedTexture")]
		[return: NativeName(NativeNameType.Type, "aiTexture const *")]
		public static AiTexture* GetEmbeddedTexture([NativeName(NativeNameType.Param, "pIn")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pIn, [NativeName(NativeNameType.Param, "filename")] [NativeName(NativeNameType.Type, "char const *")] ref byte filename)
		{
			fixed (AiScene* ppIn = &pIn)
			{
				fixed (byte* pfilename = &filename)
				{
					AiTexture* ret = GetEmbeddedTextureNative((AiScene*)ppIn, (byte*)pfilename);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns an embedded texture, or nullptr.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetEmbeddedTexture")]
		[return: NativeName(NativeNameType.Type, "aiTexture const *")]
		public static AiTexture* GetEmbeddedTexture([NativeName(NativeNameType.Param, "pIn")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pIn, [NativeName(NativeNameType.Param, "filename")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> filename)
		{
			fixed (AiScene* ppIn = &pIn)
			{
				fixed (byte* pfilename = filename)
				{
					AiTexture* ret = GetEmbeddedTextureNative((AiScene*)ppIn, (byte*)pfilename);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns an embedded texture, or nullptr.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetEmbeddedTexture")]
		[return: NativeName(NativeNameType.Type, "aiTexture const *")]
		public static AiTexture* GetEmbeddedTexture([NativeName(NativeNameType.Param, "pIn")] [NativeName(NativeNameType.Type, "aiScene const *")] ref AiScene pIn, [NativeName(NativeNameType.Param, "filename")] [NativeName(NativeNameType.Type, "char const *")] string filename)
		{
			fixed (AiScene* ppIn = &pIn)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AiTexture* ret = GetEmbeddedTextureNative((AiScene*)ppIn, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create an empty property store. Property stores are used to collect import<br/>
		/// settings.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiCreatePropertyStore")]
		[return: NativeName(NativeNameType.Type, "aiPropertyStore *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static AiPropertyStore* CreatePropertyStoreNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<AiPropertyStore*>)funcTable[27])();
			#else
			return (AiPropertyStore*)((delegate* unmanaged[Cdecl]<nint>)funcTable[27])();
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create an empty property store. Property stores are used to collect import<br/>
		/// settings.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiCreatePropertyStore")]
		[return: NativeName(NativeNameType.Type, "aiPropertyStore *")]
		public static AiPropertyStore* CreatePropertyStore()
		{
			AiPropertyStore* ret = CreatePropertyStoreNative();
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Delete a property store.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiReleasePropertyStore")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReleasePropertyStoreNative([NativeName(NativeNameType.Param, "p")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* p)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<AiPropertyStore*, void>)funcTable[28])(p);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[28])((nint)p);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Delete a property store.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiReleasePropertyStore")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleasePropertyStore([NativeName(NativeNameType.Param, "p")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* p)
		{
			ReleasePropertyStoreNative(p);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Delete a property store.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiReleasePropertyStore")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleasePropertyStore([NativeName(NativeNameType.Param, "p")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] ref AiPropertyStore p)
		{
			fixed (AiPropertyStore* pp = &p)
			{
				ReleasePropertyStoreNative((AiPropertyStore*)pp);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set an integer property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyInteger(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyInteger")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetImportPropertyIntegerNative([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] byte* szName, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<AiPropertyStore*, byte*, int, void>)funcTable[29])(store, szName, value);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, void>)funcTable[29])((nint)store, (nint)szName, value);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set an integer property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyInteger(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyInteger")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyInteger([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] byte* szName, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value)
		{
			SetImportPropertyIntegerNative(store, szName, value);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set an integer property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyInteger(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyInteger")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyInteger([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] ref AiPropertyStore store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] byte* szName, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value)
		{
			fixed (AiPropertyStore* pstore = &store)
			{
				SetImportPropertyIntegerNative((AiPropertyStore*)pstore, szName, value);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set an integer property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyInteger(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyInteger")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyInteger([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] ref byte szName, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value)
		{
			fixed (byte* pszName = &szName)
			{
				SetImportPropertyIntegerNative(store, (byte*)pszName, value);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set an integer property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyInteger(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyInteger")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyInteger([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> szName, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value)
		{
			fixed (byte* pszName = szName)
			{
				SetImportPropertyIntegerNative(store, (byte*)pszName, value);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set an integer property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyInteger(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyInteger")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyInteger([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] string szName, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (szName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(szName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(szName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetImportPropertyIntegerNative(store, pStr0, value);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set an integer property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyInteger(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyInteger")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyInteger([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] ref AiPropertyStore store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] ref byte szName, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value)
		{
			fixed (AiPropertyStore* pstore = &store)
			{
				fixed (byte* pszName = &szName)
				{
					SetImportPropertyIntegerNative((AiPropertyStore*)pstore, (byte*)pszName, value);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set an integer property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyInteger(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyInteger")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyInteger([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] ref AiPropertyStore store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> szName, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value)
		{
			fixed (AiPropertyStore* pstore = &store)
			{
				fixed (byte* pszName = szName)
				{
					SetImportPropertyIntegerNative((AiPropertyStore*)pstore, (byte*)pszName, value);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set an integer property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyInteger(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyInteger")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyInteger([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] ref AiPropertyStore store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] string szName, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value)
		{
			fixed (AiPropertyStore* pstore = &store)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (szName != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(szName);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(szName, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SetImportPropertyIntegerNative((AiPropertyStore*)pstore, pStr0, value);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a floating-point property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyFloat(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyFloat")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetImportPropertyFloatNative([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] byte* szName, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "ai_real")] double value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<AiPropertyStore*, byte*, double, void>)funcTable[30])(store, szName, value);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, double, void>)funcTable[30])((nint)store, (nint)szName, value);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Set a floating-point property.<br/>
		/// This is the C-version of #Assimp::Importer::SetPropertyFloat(). In the C<br/>
		/// interface, properties are always shared by all imports. It is not possible to<br/>
		/// specify them per import.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiSetImportPropertyFloat")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetImportPropertyFloat([NativeName(NativeNameType.Param, "store")] [NativeName(NativeNameType.Type, "aiPropertyStore *")] AiPropertyStore* store, [NativeName(NativeNameType.Param, "szName")] [NativeName(NativeNameType.Type, "char const *")] byte* szName, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "ai_real")] double value)
		{
			SetImportPropertyFloatNative(store, szName, value);
		}
	}
}
