// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.Assimp
{
	public unsafe partial class Assimp
	{

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 4x4 matrix from scaling, rotation and position.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromScalingQuaternionPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromScalingQuaternionPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 position)
		{
			fixed (Quaternion* protation = &rotation)
			{
				fixed (Vector3* pposition = &position)
				{
					Matrix4FromScalingQuaternionPositionNative(mat, scaling, (Quaternion*)protation, (Vector3*)pposition);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 4x4 matrix from scaling, rotation and position.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromScalingQuaternionPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromScalingQuaternionPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Quaternion* protation = &rotation)
				{
					fixed (Vector3* pposition = &position)
					{
						Matrix4FromScalingQuaternionPositionNative((Matrix4x4*)pmat, scaling, (Quaternion*)protation, (Vector3*)pposition);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 4x4 matrix from scaling, rotation and position.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromScalingQuaternionPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromScalingQuaternionPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 position)
		{
			fixed (Vector3* pscaling = &scaling)
			{
				fixed (Quaternion* protation = &rotation)
				{
					fixed (Vector3* pposition = &position)
					{
						Matrix4FromScalingQuaternionPositionNative(mat, (Vector3*)pscaling, (Quaternion*)protation, (Vector3*)pposition);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Construct a 4x4 matrix from scaling, rotation and position.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromScalingQuaternionPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromScalingQuaternionPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* pscaling = &scaling)
				{
					fixed (Quaternion* protation = &rotation)
					{
						fixed (Vector3* pposition = &position)
						{
							Matrix4FromScalingQuaternionPositionNative((Matrix4x4*)pmat, (Vector3*)pscaling, (Quaternion*)protation, (Vector3*)pposition);
						}
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Add 4x4 matrices.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4Add")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Matrix4AddNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* src)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Matrix4x4*, Matrix4x4*, void>)funcTable[87])(dst, src);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[87])((nint)dst, (nint)src);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Add 4x4 matrices.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4Add")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4Add([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* src)
		{
			Matrix4AddNative(dst, src);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Add 4x4 matrices.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4Add")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4Add([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* src)
		{
			fixed (Matrix4x4* pdst = &dst)
			{
				Matrix4AddNative((Matrix4x4*)pdst, src);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Add 4x4 matrices.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4Add")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4Add([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 src)
		{
			fixed (Matrix4x4* psrc = &src)
			{
				Matrix4AddNative(dst, (Matrix4x4*)psrc);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Add 4x4 matrices.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4Add")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4Add([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 src)
		{
			fixed (Matrix4x4* pdst = &dst)
			{
				fixed (Matrix4x4* psrc = &src)
				{
					Matrix4AddNative((Matrix4x4*)pdst, (Matrix4x4*)psrc);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 4x4 matrices are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4AreEqual")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int Matrix4AreEqualNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Matrix4x4*, Matrix4x4*, int>)funcTable[88])(a, b);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[88])((nint)a, (nint)b);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 4x4 matrices are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4AreEqual")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Matrix4AreEqual([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* b)
		{
			int ret = Matrix4AreEqualNative(a, b);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 4x4 matrices are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4AreEqual")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Matrix4AreEqual([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* b)
		{
			fixed (Matrix4x4* pa = &a)
			{
				int ret = Matrix4AreEqualNative((Matrix4x4*)pa, b);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 4x4 matrices are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4AreEqual")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Matrix4AreEqual([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 b)
		{
			fixed (Matrix4x4* pb = &b)
			{
				int ret = Matrix4AreEqualNative(a, (Matrix4x4*)pb);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 4x4 matrices are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4AreEqual")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Matrix4AreEqual([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 b)
		{
			fixed (Matrix4x4* pa = &a)
			{
				fixed (Matrix4x4* pb = &b)
				{
					int ret = Matrix4AreEqualNative((Matrix4x4*)pa, (Matrix4x4*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 4x4 matrices are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4AreEqualEpsilon")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int Matrix4AreEqualEpsilonNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* b, [NativeName(NativeNameType.Param, "epsilon")] [NativeName(NativeNameType.Type, "float const")] float epsilon)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Matrix4x4*, Matrix4x4*, float, int>)funcTable[89])(a, b, epsilon);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, float, int>)funcTable[89])((nint)a, (nint)b, epsilon);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 4x4 matrices are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4AreEqualEpsilon")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Matrix4AreEqualEpsilon([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* b, [NativeName(NativeNameType.Param, "epsilon")] [NativeName(NativeNameType.Type, "float const")] float epsilon)
		{
			int ret = Matrix4AreEqualEpsilonNative(a, b, epsilon);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 4x4 matrices are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4AreEqualEpsilon")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Matrix4AreEqualEpsilon([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* b, [NativeName(NativeNameType.Param, "epsilon")] [NativeName(NativeNameType.Type, "float const")] float epsilon)
		{
			fixed (Matrix4x4* pa = &a)
			{
				int ret = Matrix4AreEqualEpsilonNative((Matrix4x4*)pa, b, epsilon);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 4x4 matrices are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4AreEqualEpsilon")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Matrix4AreEqualEpsilon([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 b, [NativeName(NativeNameType.Param, "epsilon")] [NativeName(NativeNameType.Type, "float const")] float epsilon)
		{
			fixed (Matrix4x4* pb = &b)
			{
				int ret = Matrix4AreEqualEpsilonNative(a, (Matrix4x4*)pb, epsilon);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if 4x4 matrices are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4AreEqualEpsilon")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Matrix4AreEqualEpsilon([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 b, [NativeName(NativeNameType.Param, "epsilon")] [NativeName(NativeNameType.Type, "float const")] float epsilon)
		{
			fixed (Matrix4x4* pa = &a)
			{
				fixed (Matrix4x4* pb = &b)
				{
					int ret = Matrix4AreEqualEpsilonNative((Matrix4x4*)pa, (Matrix4x4*)pb, epsilon);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Invert a 4x4 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4Inverse")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Matrix4InverseNative([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Matrix4x4*, void>)funcTable[90])(mat);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[90])((nint)mat);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Invert a 4x4 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4Inverse")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4Inverse([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat)
		{
			Matrix4InverseNative(mat);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Invert a 4x4 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4Inverse")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4Inverse([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 mat)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				Matrix4InverseNative((Matrix4x4*)pmat);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the determinant of a 4x4 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4Determinant")]
		[return: NativeName(NativeNameType.Type, "ai_real")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double Matrix4DeterminantNative([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Matrix4x4*, double>)funcTable[91])(mat);
			#else
			return (double)((delegate* unmanaged[Cdecl]<nint, double>)funcTable[91])((nint)mat);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the determinant of a 4x4 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4Determinant")]
		[return: NativeName(NativeNameType.Type, "ai_real")]
		public static double Matrix4Determinant([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat)
		{
			double ret = Matrix4DeterminantNative(mat);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get the determinant of a 4x4 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4Determinant")]
		[return: NativeName(NativeNameType.Type, "ai_real")]
		public static double Matrix4Determinant([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				double ret = Matrix4DeterminantNative((Matrix4x4*)pmat);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns true of the matrix is the identity matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4IsIdentity")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int Matrix4IsIdentityNative([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Matrix4x4*, int>)funcTable[92])(mat);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[92])((nint)mat);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns true of the matrix is the identity matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4IsIdentity")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Matrix4IsIdentity([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat)
		{
			int ret = Matrix4IsIdentityNative(mat);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns true of the matrix is the identity matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4IsIdentity")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Matrix4IsIdentity([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				int ret = Matrix4IsIdentityNative((Matrix4x4*)pmat);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational as euler angles, and translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingEulerAnglesPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Matrix4DecomposeIntoScalingEulerAnglesPositionNative([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Matrix4x4*, Vector3*, Vector3*, Vector3*, void>)funcTable[93])(mat, scaling, rotation, position);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, void>)funcTable[93])((nint)mat, (nint)scaling, (nint)rotation, (nint)position);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational as euler angles, and translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingEulerAnglesPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingEulerAnglesPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			Matrix4DecomposeIntoScalingEulerAnglesPositionNative(mat, scaling, rotation, position);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational as euler angles, and translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingEulerAnglesPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingEulerAnglesPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				Matrix4DecomposeIntoScalingEulerAnglesPositionNative((Matrix4x4*)pmat, scaling, rotation, position);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational as euler angles, and translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingEulerAnglesPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingEulerAnglesPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Vector3* pscaling = &scaling)
			{
				Matrix4DecomposeIntoScalingEulerAnglesPositionNative(mat, (Vector3*)pscaling, rotation, position);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational as euler angles, and translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingEulerAnglesPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingEulerAnglesPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* pscaling = &scaling)
				{
					Matrix4DecomposeIntoScalingEulerAnglesPositionNative((Matrix4x4*)pmat, (Vector3*)pscaling, rotation, position);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational as euler angles, and translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingEulerAnglesPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingEulerAnglesPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Vector3* protation = &rotation)
			{
				Matrix4DecomposeIntoScalingEulerAnglesPositionNative(mat, scaling, (Vector3*)protation, position);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational as euler angles, and translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingEulerAnglesPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingEulerAnglesPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* protation = &rotation)
				{
					Matrix4DecomposeIntoScalingEulerAnglesPositionNative((Matrix4x4*)pmat, scaling, (Vector3*)protation, position);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational as euler angles, and translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingEulerAnglesPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingEulerAnglesPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Vector3* pscaling = &scaling)
			{
				fixed (Vector3* protation = &rotation)
				{
					Matrix4DecomposeIntoScalingEulerAnglesPositionNative(mat, (Vector3*)pscaling, (Vector3*)protation, position);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational as euler angles, and translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingEulerAnglesPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingEulerAnglesPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* pscaling = &scaling)
				{
					fixed (Vector3* protation = &rotation)
					{
						Matrix4DecomposeIntoScalingEulerAnglesPositionNative((Matrix4x4*)pmat, (Vector3*)pscaling, (Vector3*)protation, position);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational as euler angles, and translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingEulerAnglesPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingEulerAnglesPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Vector3* pposition = &position)
			{
				Matrix4DecomposeIntoScalingEulerAnglesPositionNative(mat, scaling, rotation, (Vector3*)pposition);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational as euler angles, and translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingEulerAnglesPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingEulerAnglesPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* pposition = &position)
				{
					Matrix4DecomposeIntoScalingEulerAnglesPositionNative((Matrix4x4*)pmat, scaling, rotation, (Vector3*)pposition);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational as euler angles, and translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingEulerAnglesPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingEulerAnglesPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Vector3* pscaling = &scaling)
			{
				fixed (Vector3* pposition = &position)
				{
					Matrix4DecomposeIntoScalingEulerAnglesPositionNative(mat, (Vector3*)pscaling, rotation, (Vector3*)pposition);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational as euler angles, and translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingEulerAnglesPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingEulerAnglesPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* pscaling = &scaling)
				{
					fixed (Vector3* pposition = &position)
					{
						Matrix4DecomposeIntoScalingEulerAnglesPositionNative((Matrix4x4*)pmat, (Vector3*)pscaling, rotation, (Vector3*)pposition);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational as euler angles, and translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingEulerAnglesPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingEulerAnglesPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Vector3* protation = &rotation)
			{
				fixed (Vector3* pposition = &position)
				{
					Matrix4DecomposeIntoScalingEulerAnglesPositionNative(mat, scaling, (Vector3*)protation, (Vector3*)pposition);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational as euler angles, and translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingEulerAnglesPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingEulerAnglesPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* protation = &rotation)
				{
					fixed (Vector3* pposition = &position)
					{
						Matrix4DecomposeIntoScalingEulerAnglesPositionNative((Matrix4x4*)pmat, scaling, (Vector3*)protation, (Vector3*)pposition);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational as euler angles, and translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingEulerAnglesPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingEulerAnglesPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Vector3* pscaling = &scaling)
			{
				fixed (Vector3* protation = &rotation)
				{
					fixed (Vector3* pposition = &position)
					{
						Matrix4DecomposeIntoScalingEulerAnglesPositionNative(mat, (Vector3*)pscaling, (Vector3*)protation, (Vector3*)pposition);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational as euler angles, and translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingEulerAnglesPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingEulerAnglesPosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* pscaling = &scaling)
				{
					fixed (Vector3* protation = &rotation)
					{
						fixed (Vector3* pposition = &position)
						{
							Matrix4DecomposeIntoScalingEulerAnglesPositionNative((Matrix4x4*)pmat, (Vector3*)pscaling, (Vector3*)protation, (Vector3*)pposition);
						}
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Matrix4DecomposeIntoScalingAxisAnglePositionNative([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] double* angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Matrix4x4*, Vector3*, Vector3*, double*, Vector3*, void>)funcTable[94])(mat, scaling, axis, angle, position);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, void>)funcTable[94])((nint)mat, (nint)scaling, (nint)axis, (nint)angle, (nint)position);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] double* angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			Matrix4DecomposeIntoScalingAxisAnglePositionNative(mat, scaling, axis, angle, position);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] double* angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				Matrix4DecomposeIntoScalingAxisAnglePositionNative((Matrix4x4*)pmat, scaling, axis, angle, position);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] double* angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Vector3* pscaling = &scaling)
			{
				Matrix4DecomposeIntoScalingAxisAnglePositionNative(mat, (Vector3*)pscaling, axis, angle, position);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] double* angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* pscaling = &scaling)
				{
					Matrix4DecomposeIntoScalingAxisAnglePositionNative((Matrix4x4*)pmat, (Vector3*)pscaling, axis, angle, position);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] double* angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Vector3* paxis = &axis)
			{
				Matrix4DecomposeIntoScalingAxisAnglePositionNative(mat, scaling, (Vector3*)paxis, angle, position);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] double* angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* paxis = &axis)
				{
					Matrix4DecomposeIntoScalingAxisAnglePositionNative((Matrix4x4*)pmat, scaling, (Vector3*)paxis, angle, position);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] double* angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Vector3* pscaling = &scaling)
			{
				fixed (Vector3* paxis = &axis)
				{
					Matrix4DecomposeIntoScalingAxisAnglePositionNative(mat, (Vector3*)pscaling, (Vector3*)paxis, angle, position);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] double* angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* pscaling = &scaling)
				{
					fixed (Vector3* paxis = &axis)
					{
						Matrix4DecomposeIntoScalingAxisAnglePositionNative((Matrix4x4*)pmat, (Vector3*)pscaling, (Vector3*)paxis, angle, position);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] ref double angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (double* pangle = &angle)
			{
				Matrix4DecomposeIntoScalingAxisAnglePositionNative(mat, scaling, axis, (double*)pangle, position);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] ref double angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (double* pangle = &angle)
				{
					Matrix4DecomposeIntoScalingAxisAnglePositionNative((Matrix4x4*)pmat, scaling, axis, (double*)pangle, position);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] ref double angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Vector3* pscaling = &scaling)
			{
				fixed (double* pangle = &angle)
				{
					Matrix4DecomposeIntoScalingAxisAnglePositionNative(mat, (Vector3*)pscaling, axis, (double*)pangle, position);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] ref double angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* pscaling = &scaling)
				{
					fixed (double* pangle = &angle)
					{
						Matrix4DecomposeIntoScalingAxisAnglePositionNative((Matrix4x4*)pmat, (Vector3*)pscaling, axis, (double*)pangle, position);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] ref double angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Vector3* paxis = &axis)
			{
				fixed (double* pangle = &angle)
				{
					Matrix4DecomposeIntoScalingAxisAnglePositionNative(mat, scaling, (Vector3*)paxis, (double*)pangle, position);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] ref double angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* paxis = &axis)
				{
					fixed (double* pangle = &angle)
					{
						Matrix4DecomposeIntoScalingAxisAnglePositionNative((Matrix4x4*)pmat, scaling, (Vector3*)paxis, (double*)pangle, position);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] ref double angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Vector3* pscaling = &scaling)
			{
				fixed (Vector3* paxis = &axis)
				{
					fixed (double* pangle = &angle)
					{
						Matrix4DecomposeIntoScalingAxisAnglePositionNative(mat, (Vector3*)pscaling, (Vector3*)paxis, (double*)pangle, position);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] ref double angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* pscaling = &scaling)
				{
					fixed (Vector3* paxis = &axis)
					{
						fixed (double* pangle = &angle)
						{
							Matrix4DecomposeIntoScalingAxisAnglePositionNative((Matrix4x4*)pmat, (Vector3*)pscaling, (Vector3*)paxis, (double*)pangle, position);
						}
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] double* angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Vector3* pposition = &position)
			{
				Matrix4DecomposeIntoScalingAxisAnglePositionNative(mat, scaling, axis, angle, (Vector3*)pposition);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] double* angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* pposition = &position)
				{
					Matrix4DecomposeIntoScalingAxisAnglePositionNative((Matrix4x4*)pmat, scaling, axis, angle, (Vector3*)pposition);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] double* angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Vector3* pscaling = &scaling)
			{
				fixed (Vector3* pposition = &position)
				{
					Matrix4DecomposeIntoScalingAxisAnglePositionNative(mat, (Vector3*)pscaling, axis, angle, (Vector3*)pposition);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] double* angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* pscaling = &scaling)
				{
					fixed (Vector3* pposition = &position)
					{
						Matrix4DecomposeIntoScalingAxisAnglePositionNative((Matrix4x4*)pmat, (Vector3*)pscaling, axis, angle, (Vector3*)pposition);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] double* angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Vector3* paxis = &axis)
			{
				fixed (Vector3* pposition = &position)
				{
					Matrix4DecomposeIntoScalingAxisAnglePositionNative(mat, scaling, (Vector3*)paxis, angle, (Vector3*)pposition);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] double* angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* paxis = &axis)
				{
					fixed (Vector3* pposition = &position)
					{
						Matrix4DecomposeIntoScalingAxisAnglePositionNative((Matrix4x4*)pmat, scaling, (Vector3*)paxis, angle, (Vector3*)pposition);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] double* angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Vector3* pscaling = &scaling)
			{
				fixed (Vector3* paxis = &axis)
				{
					fixed (Vector3* pposition = &position)
					{
						Matrix4DecomposeIntoScalingAxisAnglePositionNative(mat, (Vector3*)pscaling, (Vector3*)paxis, angle, (Vector3*)pposition);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] double* angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* pscaling = &scaling)
				{
					fixed (Vector3* paxis = &axis)
					{
						fixed (Vector3* pposition = &position)
						{
							Matrix4DecomposeIntoScalingAxisAnglePositionNative((Matrix4x4*)pmat, (Vector3*)pscaling, (Vector3*)paxis, angle, (Vector3*)pposition);
						}
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] ref double angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (double* pangle = &angle)
			{
				fixed (Vector3* pposition = &position)
				{
					Matrix4DecomposeIntoScalingAxisAnglePositionNative(mat, scaling, axis, (double*)pangle, (Vector3*)pposition);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] ref double angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (double* pangle = &angle)
				{
					fixed (Vector3* pposition = &position)
					{
						Matrix4DecomposeIntoScalingAxisAnglePositionNative((Matrix4x4*)pmat, scaling, axis, (double*)pangle, (Vector3*)pposition);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] ref double angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Vector3* pscaling = &scaling)
			{
				fixed (double* pangle = &angle)
				{
					fixed (Vector3* pposition = &position)
					{
						Matrix4DecomposeIntoScalingAxisAnglePositionNative(mat, (Vector3*)pscaling, axis, (double*)pangle, (Vector3*)pposition);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] ref double angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* pscaling = &scaling)
				{
					fixed (double* pangle = &angle)
					{
						fixed (Vector3* pposition = &position)
						{
							Matrix4DecomposeIntoScalingAxisAnglePositionNative((Matrix4x4*)pmat, (Vector3*)pscaling, axis, (double*)pangle, (Vector3*)pposition);
						}
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] ref double angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Vector3* paxis = &axis)
			{
				fixed (double* pangle = &angle)
				{
					fixed (Vector3* pposition = &position)
					{
						Matrix4DecomposeIntoScalingAxisAnglePositionNative(mat, scaling, (Vector3*)paxis, (double*)pangle, (Vector3*)pposition);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] ref double angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* paxis = &axis)
				{
					fixed (double* pangle = &angle)
					{
						fixed (Vector3* pposition = &position)
						{
							Matrix4DecomposeIntoScalingAxisAnglePositionNative((Matrix4x4*)pmat, scaling, (Vector3*)paxis, (double*)pangle, (Vector3*)pposition);
						}
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] ref double angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Vector3* pscaling = &scaling)
			{
				fixed (Vector3* paxis = &axis)
				{
					fixed (double* pangle = &angle)
					{
						fixed (Vector3* pposition = &position)
						{
							Matrix4DecomposeIntoScalingAxisAnglePositionNative(mat, (Vector3*)pscaling, (Vector3*)paxis, (double*)pangle, (Vector3*)pposition);
						}
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its scaling,<br/>
		/// rotational split into an axis and rotational angle,<br/>
		/// and it's translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeIntoScalingAxisAnglePosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeIntoScalingAxisAnglePosition([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 scaling, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "ai_real *")] ref double angle, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* pscaling = &scaling)
				{
					fixed (Vector3* paxis = &axis)
					{
						fixed (double* pangle = &angle)
						{
							fixed (Vector3* pposition = &position)
							{
								Matrix4DecomposeIntoScalingAxisAnglePositionNative((Matrix4x4*)pmat, (Vector3*)pscaling, (Vector3*)paxis, (double*)pangle, (Vector3*)pposition);
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its rotational and<br/>
		/// translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeNoScaling")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Matrix4DecomposeNoScalingNative([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Matrix4x4*, Quaternion*, Vector3*, void>)funcTable[95])(mat, rotation, position);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[95])((nint)mat, (nint)rotation, (nint)position);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its rotational and<br/>
		/// translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeNoScaling")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeNoScaling([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			Matrix4DecomposeNoScalingNative(mat, rotation, position);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its rotational and<br/>
		/// translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeNoScaling")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeNoScaling([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				Matrix4DecomposeNoScalingNative((Matrix4x4*)pmat, rotation, position);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its rotational and<br/>
		/// translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeNoScaling")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeNoScaling([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion *")] ref Quaternion rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Quaternion* protation = &rotation)
			{
				Matrix4DecomposeNoScalingNative(mat, (Quaternion*)protation, position);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its rotational and<br/>
		/// translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeNoScaling")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeNoScaling([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion *")] ref Quaternion rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] Vector3* position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Quaternion* protation = &rotation)
				{
					Matrix4DecomposeNoScalingNative((Matrix4x4*)pmat, (Quaternion*)protation, position);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its rotational and<br/>
		/// translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeNoScaling")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeNoScaling([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Vector3* pposition = &position)
			{
				Matrix4DecomposeNoScalingNative(mat, rotation, (Vector3*)pposition);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its rotational and<br/>
		/// translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeNoScaling")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeNoScaling([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* pposition = &position)
				{
					Matrix4DecomposeNoScalingNative((Matrix4x4*)pmat, rotation, (Vector3*)pposition);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its rotational and<br/>
		/// translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeNoScaling")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeNoScaling([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion *")] ref Quaternion rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Quaternion* protation = &rotation)
			{
				fixed (Vector3* pposition = &position)
				{
					Matrix4DecomposeNoScalingNative(mat, (Quaternion*)protation, (Vector3*)pposition);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Decompose a transformation matrix into its rotational and<br/>
		/// translational components.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4DecomposeNoScaling")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4DecomposeNoScaling([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 const *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "aiQuaternion *")] ref Quaternion rotation, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "aiVector3D *")] ref Vector3 position)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Quaternion* protation = &rotation)
				{
					fixed (Vector3* pposition = &position)
					{
						Matrix4DecomposeNoScalingNative((Matrix4x4*)pmat, (Quaternion*)protation, (Vector3*)pposition);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Creates a 4x4 matrix from a set of euler angles.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromEulerAngles")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Matrix4FromEulerAnglesNative([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "z")] [NativeName(NativeNameType.Type, "float")] float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Matrix4x4*, float, float, float, void>)funcTable[96])(mat, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, float, float, void>)funcTable[96])((nint)mat, x, y, z);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Creates a 4x4 matrix from a set of euler angles.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromEulerAngles")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromEulerAngles([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "z")] [NativeName(NativeNameType.Type, "float")] float z)
		{
			Matrix4FromEulerAnglesNative(mat, x, y, z);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Creates a 4x4 matrix from a set of euler angles.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromEulerAngles")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromEulerAngles([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "z")] [NativeName(NativeNameType.Type, "float")] float z)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				Matrix4FromEulerAnglesNative((Matrix4x4*)pmat, x, y, z);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 4x4 rotation matrix around the X axis.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4RotationX")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Matrix4RotationXNative([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "float const")] float angle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Matrix4x4*, float, void>)funcTable[97])(mat, angle);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, void>)funcTable[97])((nint)mat, angle);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 4x4 rotation matrix around the X axis.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4RotationX")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4RotationX([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "float const")] float angle)
		{
			Matrix4RotationXNative(mat, angle);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 4x4 rotation matrix around the X axis.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4RotationX")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4RotationX([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "float const")] float angle)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				Matrix4RotationXNative((Matrix4x4*)pmat, angle);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 4x4 rotation matrix around the Y axis.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4RotationY")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Matrix4RotationYNative([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "float const")] float angle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Matrix4x4*, float, void>)funcTable[98])(mat, angle);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, void>)funcTable[98])((nint)mat, angle);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 4x4 rotation matrix around the Y axis.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4RotationY")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4RotationY([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "float const")] float angle)
		{
			Matrix4RotationYNative(mat, angle);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 4x4 rotation matrix around the Y axis.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4RotationY")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4RotationY([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "float const")] float angle)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				Matrix4RotationYNative((Matrix4x4*)pmat, angle);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 4x4 rotation matrix around the Z axis.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4RotationZ")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Matrix4RotationZNative([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "float const")] float angle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Matrix4x4*, float, void>)funcTable[99])(mat, angle);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, void>)funcTable[99])((nint)mat, angle);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 4x4 rotation matrix around the Z axis.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4RotationZ")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4RotationZ([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "float const")] float angle)
		{
			Matrix4RotationZNative(mat, angle);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 4x4 rotation matrix around the Z axis.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4RotationZ")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4RotationZ([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "float const")] float angle)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				Matrix4RotationZNative((Matrix4x4*)pmat, angle);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns a 4x4 rotation matrix for a rotation around an arbitrary axis.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromRotationAroundAxis")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Matrix4FromRotationAroundAxisNative([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "float const")] float angle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Matrix4x4*, Vector3*, float, void>)funcTable[100])(mat, axis, angle);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, float, void>)funcTable[100])((nint)mat, (nint)axis, angle);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns a 4x4 rotation matrix for a rotation around an arbitrary axis.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromRotationAroundAxis")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromRotationAroundAxis([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "float const")] float angle)
		{
			Matrix4FromRotationAroundAxisNative(mat, axis, angle);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns a 4x4 rotation matrix for a rotation around an arbitrary axis.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromRotationAroundAxis")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromRotationAroundAxis([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "float const")] float angle)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				Matrix4FromRotationAroundAxisNative((Matrix4x4*)pmat, axis, angle);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns a 4x4 rotation matrix for a rotation around an arbitrary axis.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromRotationAroundAxis")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromRotationAroundAxis([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "float const")] float angle)
		{
			fixed (Vector3* paxis = &axis)
			{
				Matrix4FromRotationAroundAxisNative(mat, (Vector3*)paxis, angle);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Returns a 4x4 rotation matrix for a rotation around an arbitrary axis.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromRotationAroundAxis")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromRotationAroundAxis([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "float const")] float angle)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* paxis = &axis)
				{
					Matrix4FromRotationAroundAxisNative((Matrix4x4*)pmat, (Vector3*)paxis, angle);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 4x4 translation matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4Translation")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Matrix4TranslationNative([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "translation")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* translation)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Matrix4x4*, Vector3*, void>)funcTable[101])(mat, translation);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[101])((nint)mat, (nint)translation);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 4x4 translation matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4Translation")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4Translation([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "translation")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* translation)
		{
			Matrix4TranslationNative(mat, translation);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 4x4 translation matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4Translation")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4Translation([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "translation")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* translation)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				Matrix4TranslationNative((Matrix4x4*)pmat, translation);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 4x4 translation matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4Translation")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4Translation([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "translation")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 translation)
		{
			fixed (Vector3* ptranslation = &translation)
			{
				Matrix4TranslationNative(mat, (Vector3*)ptranslation);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 4x4 translation matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4Translation")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4Translation([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "translation")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 translation)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* ptranslation = &translation)
				{
					Matrix4TranslationNative((Matrix4x4*)pmat, (Vector3*)ptranslation);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 4x4 scaling matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4Scaling")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Matrix4ScalingNative([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* scaling)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Matrix4x4*, Vector3*, void>)funcTable[102])(mat, scaling);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[102])((nint)mat, (nint)scaling);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 4x4 scaling matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4Scaling")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4Scaling([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* scaling)
		{
			Matrix4ScalingNative(mat, scaling);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 4x4 scaling matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4Scaling")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4Scaling([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* scaling)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				Matrix4ScalingNative((Matrix4x4*)pmat, scaling);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 4x4 scaling matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4Scaling")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4Scaling([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 scaling)
		{
			fixed (Vector3* pscaling = &scaling)
			{
				Matrix4ScalingNative(mat, (Vector3*)pscaling);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Get a 4x4 scaling matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4Scaling")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4Scaling([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "scaling")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 scaling)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* pscaling = &scaling)
				{
					Matrix4ScalingNative((Matrix4x4*)pmat, (Vector3*)pscaling);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a 4x4 matrix that rotates one vector to another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromTo")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Matrix4FromToNative([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "from")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* from, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* to)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Matrix4x4*, Vector3*, Vector3*, void>)funcTable[103])(mat, from, to);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[103])((nint)mat, (nint)from, (nint)to);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a 4x4 matrix that rotates one vector to another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromTo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromTo([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "from")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* from, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* to)
		{
			Matrix4FromToNative(mat, from, to);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a 4x4 matrix that rotates one vector to another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromTo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromTo([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "from")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* from, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* to)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				Matrix4FromToNative((Matrix4x4*)pmat, from, to);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a 4x4 matrix that rotates one vector to another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromTo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromTo([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "from")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 from, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* to)
		{
			fixed (Vector3* pfrom = &from)
			{
				Matrix4FromToNative(mat, (Vector3*)pfrom, to);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a 4x4 matrix that rotates one vector to another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromTo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromTo([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "from")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 from, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* to)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* pfrom = &from)
				{
					Matrix4FromToNative((Matrix4x4*)pmat, (Vector3*)pfrom, to);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a 4x4 matrix that rotates one vector to another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromTo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromTo([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "from")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* from, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 to)
		{
			fixed (Vector3* pto = &to)
			{
				Matrix4FromToNative(mat, from, (Vector3*)pto);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a 4x4 matrix that rotates one vector to another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromTo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromTo([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "from")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* from, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 to)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* pto = &to)
				{
					Matrix4FromToNative((Matrix4x4*)pmat, from, (Vector3*)pto);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a 4x4 matrix that rotates one vector to another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromTo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromTo([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] Matrix4x4* mat, [NativeName(NativeNameType.Param, "from")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 from, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 to)
		{
			fixed (Vector3* pfrom = &from)
			{
				fixed (Vector3* pto = &to)
				{
					Matrix4FromToNative(mat, (Vector3*)pfrom, (Vector3*)pto);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a 4x4 matrix that rotates one vector to another vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiMatrix4FromTo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Matrix4FromTo([NativeName(NativeNameType.Param, "mat")] [NativeName(NativeNameType.Type, "aiMatrix4x4 *")] ref Matrix4x4 mat, [NativeName(NativeNameType.Param, "from")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 from, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 to)
		{
			fixed (Matrix4x4* pmat = &mat)
			{
				fixed (Vector3* pfrom = &from)
				{
					fixed (Vector3* pto = &to)
					{
						Matrix4FromToNative((Matrix4x4*)pmat, (Vector3*)pfrom, (Vector3*)pto);
					}
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a Quaternion from euler angles.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionFromEulerAngles")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void QuaternionFromEulerAnglesNative([NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* q, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "z")] [NativeName(NativeNameType.Type, "float")] float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Quaternion*, float, float, float, void>)funcTable[104])(q, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, float, float, void>)funcTable[104])((nint)q, x, y, z);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a Quaternion from euler angles.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionFromEulerAngles")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QuaternionFromEulerAngles([NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* q, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "z")] [NativeName(NativeNameType.Type, "float")] float z)
		{
			QuaternionFromEulerAnglesNative(q, x, y, z);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a Quaternion from euler angles.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionFromEulerAngles")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QuaternionFromEulerAngles([NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion *")] ref Quaternion q, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "z")] [NativeName(NativeNameType.Type, "float")] float z)
		{
			fixed (Quaternion* pq = &q)
			{
				QuaternionFromEulerAnglesNative((Quaternion*)pq, x, y, z);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a Quaternion from an axis angle pair.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionFromAxisAngle")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void QuaternionFromAxisAngleNative([NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* q, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "float const")] float angle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Quaternion*, Vector3*, float, void>)funcTable[105])(q, axis, angle);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, float, void>)funcTable[105])((nint)q, (nint)axis, angle);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a Quaternion from an axis angle pair.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionFromAxisAngle")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QuaternionFromAxisAngle([NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* q, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "float const")] float angle)
		{
			QuaternionFromAxisAngleNative(q, axis, angle);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a Quaternion from an axis angle pair.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionFromAxisAngle")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QuaternionFromAxisAngle([NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion *")] ref Quaternion q, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "float const")] float angle)
		{
			fixed (Quaternion* pq = &q)
			{
				QuaternionFromAxisAngleNative((Quaternion*)pq, axis, angle);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a Quaternion from an axis angle pair.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionFromAxisAngle")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QuaternionFromAxisAngle([NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* q, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "float const")] float angle)
		{
			fixed (Vector3* paxis = &axis)
			{
				QuaternionFromAxisAngleNative(q, (Vector3*)paxis, angle);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a Quaternion from an axis angle pair.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionFromAxisAngle")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QuaternionFromAxisAngle([NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion *")] ref Quaternion q, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 axis, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "float const")] float angle)
		{
			fixed (Quaternion* pq = &q)
			{
				fixed (Vector3* paxis = &axis)
				{
					QuaternionFromAxisAngleNative((Quaternion*)pq, (Vector3*)paxis, angle);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a Quaternion from a normalized quaternion stored<br/>
		/// in a 3D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionFromNormalizedQuaternion")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void QuaternionFromNormalizedQuaternionNative([NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* q, [NativeName(NativeNameType.Param, "normalized")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* normalized)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Quaternion*, Vector3*, void>)funcTable[106])(q, normalized);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[106])((nint)q, (nint)normalized);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a Quaternion from a normalized quaternion stored<br/>
		/// in a 3D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionFromNormalizedQuaternion")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QuaternionFromNormalizedQuaternion([NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* q, [NativeName(NativeNameType.Param, "normalized")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* normalized)
		{
			QuaternionFromNormalizedQuaternionNative(q, normalized);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a Quaternion from a normalized quaternion stored<br/>
		/// in a 3D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionFromNormalizedQuaternion")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QuaternionFromNormalizedQuaternion([NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion *")] ref Quaternion q, [NativeName(NativeNameType.Param, "normalized")] [NativeName(NativeNameType.Type, "aiVector3D const *")] Vector3* normalized)
		{
			fixed (Quaternion* pq = &q)
			{
				QuaternionFromNormalizedQuaternionNative((Quaternion*)pq, normalized);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a Quaternion from a normalized quaternion stored<br/>
		/// in a 3D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionFromNormalizedQuaternion")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QuaternionFromNormalizedQuaternion([NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* q, [NativeName(NativeNameType.Param, "normalized")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 normalized)
		{
			fixed (Vector3* pnormalized = &normalized)
			{
				QuaternionFromNormalizedQuaternionNative(q, (Vector3*)pnormalized);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Create a Quaternion from a normalized quaternion stored<br/>
		/// in a 3D vector.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionFromNormalizedQuaternion")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QuaternionFromNormalizedQuaternion([NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion *")] ref Quaternion q, [NativeName(NativeNameType.Param, "normalized")] [NativeName(NativeNameType.Type, "aiVector3D const *")] ref Vector3 normalized)
		{
			fixed (Quaternion* pq = &q)
			{
				fixed (Vector3* pnormalized = &normalized)
				{
					QuaternionFromNormalizedQuaternionNative((Quaternion*)pq, (Vector3*)pnormalized);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if quaternions are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionAreEqual")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int QuaternionAreEqualNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Quaternion*, Quaternion*, int>)funcTable[107])(a, b);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[107])((nint)a, (nint)b);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if quaternions are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionAreEqual")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QuaternionAreEqual([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* b)
		{
			int ret = QuaternionAreEqualNative(a, b);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if quaternions are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionAreEqual")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QuaternionAreEqual([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* b)
		{
			fixed (Quaternion* pa = &a)
			{
				int ret = QuaternionAreEqualNative((Quaternion*)pa, b);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if quaternions are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionAreEqual")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QuaternionAreEqual([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion b)
		{
			fixed (Quaternion* pb = &b)
			{
				int ret = QuaternionAreEqualNative(a, (Quaternion*)pb);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if quaternions are equal.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionAreEqual")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QuaternionAreEqual([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion b)
		{
			fixed (Quaternion* pa = &a)
			{
				fixed (Quaternion* pb = &b)
				{
					int ret = QuaternionAreEqualNative((Quaternion*)pa, (Quaternion*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if quaternions are equal using epsilon.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionAreEqualEpsilon")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int QuaternionAreEqualEpsilonNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* b, [NativeName(NativeNameType.Param, "epsilon")] [NativeName(NativeNameType.Type, "float const")] float epsilon)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Quaternion*, Quaternion*, float, int>)funcTable[108])(a, b, epsilon);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, float, int>)funcTable[108])((nint)a, (nint)b, epsilon);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if quaternions are equal using epsilon.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionAreEqualEpsilon")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QuaternionAreEqualEpsilon([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* b, [NativeName(NativeNameType.Param, "epsilon")] [NativeName(NativeNameType.Type, "float const")] float epsilon)
		{
			int ret = QuaternionAreEqualEpsilonNative(a, b, epsilon);
			return ret;
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if quaternions are equal using epsilon.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionAreEqualEpsilon")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QuaternionAreEqualEpsilon([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* b, [NativeName(NativeNameType.Param, "epsilon")] [NativeName(NativeNameType.Type, "float const")] float epsilon)
		{
			fixed (Quaternion* pa = &a)
			{
				int ret = QuaternionAreEqualEpsilonNative((Quaternion*)pa, b, epsilon);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if quaternions are equal using epsilon.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionAreEqualEpsilon")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QuaternionAreEqualEpsilon([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion b, [NativeName(NativeNameType.Param, "epsilon")] [NativeName(NativeNameType.Type, "float const")] float epsilon)
		{
			fixed (Quaternion* pb = &b)
			{
				int ret = QuaternionAreEqualEpsilonNative(a, (Quaternion*)pb, epsilon);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Check if quaternions are equal using epsilon.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionAreEqualEpsilon")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int QuaternionAreEqualEpsilon([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion b, [NativeName(NativeNameType.Param, "epsilon")] [NativeName(NativeNameType.Type, "float const")] float epsilon)
		{
			fixed (Quaternion* pa = &a)
			{
				fixed (Quaternion* pb = &b)
				{
					int ret = QuaternionAreEqualEpsilonNative((Quaternion*)pa, (Quaternion*)pb, epsilon);
					return ret;
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Normalize a quaternion.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionNormalize")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void QuaternionNormalizeNative([NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* q)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Quaternion*, void>)funcTable[109])(q);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[109])((nint)q);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Normalize a quaternion.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionNormalize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QuaternionNormalize([NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* q)
		{
			QuaternionNormalizeNative(q);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Normalize a quaternion.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionNormalize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QuaternionNormalize([NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion *")] ref Quaternion q)
		{
			fixed (Quaternion* pq = &q)
			{
				QuaternionNormalizeNative((Quaternion*)pq);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Compute quaternion conjugate.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionConjugate")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void QuaternionConjugateNative([NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* q)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Quaternion*, void>)funcTable[110])(q);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[110])((nint)q);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Compute quaternion conjugate.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionConjugate")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QuaternionConjugate([NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* q)
		{
			QuaternionConjugateNative(q);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Compute quaternion conjugate.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionConjugate")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QuaternionConjugate([NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion *")] ref Quaternion q)
		{
			fixed (Quaternion* pq = &q)
			{
				QuaternionConjugateNative((Quaternion*)pq);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply quaternions.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionMultiply")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void QuaternionMultiplyNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* dst, [NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* q)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Quaternion*, Quaternion*, void>)funcTable[111])(dst, q);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[111])((nint)dst, (nint)q);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply quaternions.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionMultiply")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QuaternionMultiply([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* dst, [NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* q)
		{
			QuaternionMultiplyNative(dst, q);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply quaternions.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionMultiply")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QuaternionMultiply([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiQuaternion *")] ref Quaternion dst, [NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* q)
		{
			fixed (Quaternion* pdst = &dst)
			{
				QuaternionMultiplyNative((Quaternion*)pdst, q);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply quaternions.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionMultiply")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QuaternionMultiply([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* dst, [NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion q)
		{
			fixed (Quaternion* pq = &q)
			{
				QuaternionMultiplyNative(dst, (Quaternion*)pq);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Multiply quaternions.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionMultiply")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QuaternionMultiply([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiQuaternion *")] ref Quaternion dst, [NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion q)
		{
			fixed (Quaternion* pdst = &dst)
			{
				fixed (Quaternion* pq = &q)
				{
					QuaternionMultiplyNative((Quaternion*)pdst, (Quaternion*)pq);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Performs a spherical interpolation between two quaternions.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionInterpolate")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void QuaternionInterpolateNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* dst, [NativeName(NativeNameType.Param, "start")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* start, [NativeName(NativeNameType.Param, "end")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* end, [NativeName(NativeNameType.Param, "factor")] [NativeName(NativeNameType.Type, "float const")] float factor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Quaternion*, Quaternion*, Quaternion*, float, void>)funcTable[112])(dst, start, end, factor);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, float, void>)funcTable[112])((nint)dst, (nint)start, (nint)end, factor);
			#endif
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Performs a spherical interpolation between two quaternions.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionInterpolate")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QuaternionInterpolate([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* dst, [NativeName(NativeNameType.Param, "start")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* start, [NativeName(NativeNameType.Param, "end")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* end, [NativeName(NativeNameType.Param, "factor")] [NativeName(NativeNameType.Type, "float const")] float factor)
		{
			QuaternionInterpolateNative(dst, start, end, factor);
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Performs a spherical interpolation between two quaternions.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionInterpolate")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QuaternionInterpolate([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiQuaternion *")] ref Quaternion dst, [NativeName(NativeNameType.Param, "start")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* start, [NativeName(NativeNameType.Param, "end")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* end, [NativeName(NativeNameType.Param, "factor")] [NativeName(NativeNameType.Type, "float const")] float factor)
		{
			fixed (Quaternion* pdst = &dst)
			{
				QuaternionInterpolateNative((Quaternion*)pdst, start, end, factor);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Performs a spherical interpolation between two quaternions.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionInterpolate")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QuaternionInterpolate([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* dst, [NativeName(NativeNameType.Param, "start")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion start, [NativeName(NativeNameType.Param, "end")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* end, [NativeName(NativeNameType.Param, "factor")] [NativeName(NativeNameType.Type, "float const")] float factor)
		{
			fixed (Quaternion* pstart = &start)
			{
				QuaternionInterpolateNative(dst, (Quaternion*)pstart, end, factor);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Performs a spherical interpolation between two quaternions.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionInterpolate")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QuaternionInterpolate([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiQuaternion *")] ref Quaternion dst, [NativeName(NativeNameType.Param, "start")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion start, [NativeName(NativeNameType.Param, "end")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* end, [NativeName(NativeNameType.Param, "factor")] [NativeName(NativeNameType.Type, "float const")] float factor)
		{
			fixed (Quaternion* pdst = &dst)
			{
				fixed (Quaternion* pstart = &start)
				{
					QuaternionInterpolateNative((Quaternion*)pdst, (Quaternion*)pstart, end, factor);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Performs a spherical interpolation between two quaternions.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionInterpolate")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QuaternionInterpolate([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* dst, [NativeName(NativeNameType.Param, "start")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* start, [NativeName(NativeNameType.Param, "end")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion end, [NativeName(NativeNameType.Param, "factor")] [NativeName(NativeNameType.Type, "float const")] float factor)
		{
			fixed (Quaternion* pend = &end)
			{
				QuaternionInterpolateNative(dst, start, (Quaternion*)pend, factor);
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Performs a spherical interpolation between two quaternions.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionInterpolate")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QuaternionInterpolate([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiQuaternion *")] ref Quaternion dst, [NativeName(NativeNameType.Param, "start")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] Quaternion* start, [NativeName(NativeNameType.Param, "end")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion end, [NativeName(NativeNameType.Param, "factor")] [NativeName(NativeNameType.Type, "float const")] float factor)
		{
			fixed (Quaternion* pdst = &dst)
			{
				fixed (Quaternion* pend = &end)
				{
					QuaternionInterpolateNative((Quaternion*)pdst, start, (Quaternion*)pend, factor);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Performs a spherical interpolation between two quaternions.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionInterpolate")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QuaternionInterpolate([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiQuaternion *")] Quaternion* dst, [NativeName(NativeNameType.Param, "start")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion start, [NativeName(NativeNameType.Param, "end")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion end, [NativeName(NativeNameType.Param, "factor")] [NativeName(NativeNameType.Type, "float const")] float factor)
		{
			fixed (Quaternion* pstart = &start)
			{
				fixed (Quaternion* pend = &end)
				{
					QuaternionInterpolateNative(dst, (Quaternion*)pstart, (Quaternion*)pend, factor);
				}
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------<br/>
		/// Performs a spherical interpolation between two quaternions.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiQuaternionInterpolate")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QuaternionInterpolate([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "aiQuaternion *")] ref Quaternion dst, [NativeName(NativeNameType.Param, "start")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion start, [NativeName(NativeNameType.Param, "end")] [NativeName(NativeNameType.Type, "aiQuaternion const *")] ref Quaternion end, [NativeName(NativeNameType.Param, "factor")] [NativeName(NativeNameType.Type, "float const")] float factor)
		{
			fixed (Quaternion* pdst = &dst)
			{
				fixed (Quaternion* pstart = &start)
				{
					fixed (Quaternion* pend = &end)
					{
						QuaternionInterpolateNative((Quaternion*)pdst, (Quaternion*)pstart, (Quaternion*)pend, factor);
					}
				}
			}
		}

		/// <summary>
		/// -------------------------------------------------------------------------------<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiTextureTypeToString")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* TextureTypeToStringNative([NativeName(NativeNameType.Param, "in")] [NativeName(NativeNameType.Type, "aiTextureType")] AiTextureType input)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<AiTextureType, byte*>)funcTable[113])(input);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<AiTextureType, nint>)funcTable[113])(input);
			#endif
		}

		/// <summary>
		/// -------------------------------------------------------------------------------<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiTextureTypeToString")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* TextureTypeToString([NativeName(NativeNameType.Param, "in")] [NativeName(NativeNameType.Type, "aiTextureType")] AiTextureType input)
		{
			byte* ret = TextureTypeToStringNative(input);
			return ret;
		}

		/// <summary>
		/// -------------------------------------------------------------------------------<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiTextureTypeToString")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string TextureTypeToStringS([NativeName(NativeNameType.Param, "in")] [NativeName(NativeNameType.Type, "aiTextureType")] AiTextureType input)
		{
			string ret = Utils.DecodeStringUTF8(TextureTypeToStringNative(input));
			return ret;
		}

		/// <summary>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialProperty")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static AiReturn GetMaterialPropertyNative([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] byte* pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pPropOut")] [NativeName(NativeNameType.Type, "aiMaterialProperty const * *")] AiMaterialProperty** pPropOut)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<AiMaterial*, byte*, uint, uint, AiMaterialProperty**, AiReturn>)funcTable[114])(pMat, pKey, type, index, pPropOut);
			#else
			return (AiReturn)((delegate* unmanaged[Cdecl]<nint, nint, uint, uint, nint, AiReturn>)funcTable[114])((nint)pMat, (nint)pKey, type, index, (nint)pPropOut);
			#endif
		}

		/// <summary>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialProperty")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialProperty([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] byte* pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pPropOut")] [NativeName(NativeNameType.Type, "aiMaterialProperty const * *")] AiMaterialProperty** pPropOut)
		{
			AiReturn ret = GetMaterialPropertyNative(pMat, pKey, type, index, pPropOut);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialProperty")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialProperty([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] byte* pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pPropOut")] [NativeName(NativeNameType.Type, "aiMaterialProperty const * *")] AiMaterialProperty** pPropOut)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				AiReturn ret = GetMaterialPropertyNative((AiMaterial*)ppMat, pKey, type, index, pPropOut);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialProperty")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialProperty([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ref byte pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pPropOut")] [NativeName(NativeNameType.Type, "aiMaterialProperty const * *")] AiMaterialProperty** pPropOut)
		{
			fixed (byte* ppKey = &pKey)
			{
				AiReturn ret = GetMaterialPropertyNative(pMat, (byte*)ppKey, type, index, pPropOut);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialProperty")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialProperty([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pPropOut")] [NativeName(NativeNameType.Type, "aiMaterialProperty const * *")] AiMaterialProperty** pPropOut)
		{
			fixed (byte* ppKey = pKey)
			{
				AiReturn ret = GetMaterialPropertyNative(pMat, (byte*)ppKey, type, index, pPropOut);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialProperty")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialProperty([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] string pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pPropOut")] [NativeName(NativeNameType.Type, "aiMaterialProperty const * *")] AiMaterialProperty** pPropOut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pKey != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pKey);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pKey, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AiReturn ret = GetMaterialPropertyNative(pMat, pStr0, type, index, pPropOut);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialProperty")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialProperty([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ref byte pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pPropOut")] [NativeName(NativeNameType.Type, "aiMaterialProperty const * *")] AiMaterialProperty** pPropOut)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				fixed (byte* ppKey = &pKey)
				{
					AiReturn ret = GetMaterialPropertyNative((AiMaterial*)ppMat, (byte*)ppKey, type, index, pPropOut);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialProperty")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialProperty([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pPropOut")] [NativeName(NativeNameType.Type, "aiMaterialProperty const * *")] AiMaterialProperty** pPropOut)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				fixed (byte* ppKey = pKey)
				{
					AiReturn ret = GetMaterialPropertyNative((AiMaterial*)ppMat, (byte*)ppKey, type, index, pPropOut);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialProperty")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialProperty([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] string pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pPropOut")] [NativeName(NativeNameType.Type, "aiMaterialProperty const * *")] AiMaterialProperty** pPropOut)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pKey != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pKey);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pKey, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AiReturn ret = GetMaterialPropertyNative((AiMaterial*)ppMat, pStr0, type, index, pPropOut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialProperty")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialProperty([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] byte* pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pPropOut")] [NativeName(NativeNameType.Type, "aiMaterialProperty const * *")] ref AiMaterialProperty* pPropOut)
		{
			fixed (AiMaterialProperty** ppPropOut = &pPropOut)
			{
				AiReturn ret = GetMaterialPropertyNative(pMat, pKey, type, index, (AiMaterialProperty**)ppPropOut);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialProperty")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialProperty([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] byte* pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pPropOut")] [NativeName(NativeNameType.Type, "aiMaterialProperty const * *")] ref AiMaterialProperty* pPropOut)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				fixed (AiMaterialProperty** ppPropOut = &pPropOut)
				{
					AiReturn ret = GetMaterialPropertyNative((AiMaterial*)ppMat, pKey, type, index, (AiMaterialProperty**)ppPropOut);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialProperty")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialProperty([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ref byte pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pPropOut")] [NativeName(NativeNameType.Type, "aiMaterialProperty const * *")] ref AiMaterialProperty* pPropOut)
		{
			fixed (byte* ppKey = &pKey)
			{
				fixed (AiMaterialProperty** ppPropOut = &pPropOut)
				{
					AiReturn ret = GetMaterialPropertyNative(pMat, (byte*)ppKey, type, index, (AiMaterialProperty**)ppPropOut);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialProperty")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialProperty([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pPropOut")] [NativeName(NativeNameType.Type, "aiMaterialProperty const * *")] ref AiMaterialProperty* pPropOut)
		{
			fixed (byte* ppKey = pKey)
			{
				fixed (AiMaterialProperty** ppPropOut = &pPropOut)
				{
					AiReturn ret = GetMaterialPropertyNative(pMat, (byte*)ppKey, type, index, (AiMaterialProperty**)ppPropOut);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialProperty")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialProperty([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] string pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pPropOut")] [NativeName(NativeNameType.Type, "aiMaterialProperty const * *")] ref AiMaterialProperty* pPropOut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pKey != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pKey);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pKey, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (AiMaterialProperty** ppPropOut = &pPropOut)
			{
				AiReturn ret = GetMaterialPropertyNative(pMat, pStr0, type, index, (AiMaterialProperty**)ppPropOut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialProperty")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialProperty([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ref byte pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pPropOut")] [NativeName(NativeNameType.Type, "aiMaterialProperty const * *")] ref AiMaterialProperty* pPropOut)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				fixed (byte* ppKey = &pKey)
				{
					fixed (AiMaterialProperty** ppPropOut = &pPropOut)
					{
						AiReturn ret = GetMaterialPropertyNative((AiMaterial*)ppMat, (byte*)ppKey, type, index, (AiMaterialProperty**)ppPropOut);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialProperty")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialProperty([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pPropOut")] [NativeName(NativeNameType.Type, "aiMaterialProperty const * *")] ref AiMaterialProperty* pPropOut)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				fixed (byte* ppKey = pKey)
				{
					fixed (AiMaterialProperty** ppPropOut = &pPropOut)
					{
						AiReturn ret = GetMaterialPropertyNative((AiMaterial*)ppMat, (byte*)ppKey, type, index, (AiMaterialProperty**)ppPropOut);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialProperty")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialProperty([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] string pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pPropOut")] [NativeName(NativeNameType.Type, "aiMaterialProperty const * *")] ref AiMaterialProperty* pPropOut)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pKey != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pKey);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pKey, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (AiMaterialProperty** ppPropOut = &pPropOut)
				{
					AiReturn ret = GetMaterialPropertyNative((AiMaterial*)ppMat, pStr0, type, index, (AiMaterialProperty**)ppPropOut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static AiReturn GetMaterialFloatArrayNative([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] byte* pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] double* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<AiMaterial*, byte*, uint, uint, double*, uint*, AiReturn>)funcTable[115])(pMat, pKey, type, index, pOut, pMax);
			#else
			return (AiReturn)((delegate* unmanaged[Cdecl]<nint, nint, uint, uint, nint, nint, AiReturn>)funcTable[115])((nint)pMat, (nint)pKey, type, index, (nint)pOut, (nint)pMax);
			#endif
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] byte* pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] double* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			AiReturn ret = GetMaterialFloatArrayNative(pMat, pKey, type, index, pOut, pMax);
			return ret;
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] byte* pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] double* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				AiReturn ret = GetMaterialFloatArrayNative((AiMaterial*)ppMat, pKey, type, index, pOut, pMax);
				return ret;
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ref byte pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] double* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			fixed (byte* ppKey = &pKey)
			{
				AiReturn ret = GetMaterialFloatArrayNative(pMat, (byte*)ppKey, type, index, pOut, pMax);
				return ret;
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] double* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			fixed (byte* ppKey = pKey)
			{
				AiReturn ret = GetMaterialFloatArrayNative(pMat, (byte*)ppKey, type, index, pOut, pMax);
				return ret;
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] string pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] double* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pKey != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pKey);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pKey, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AiReturn ret = GetMaterialFloatArrayNative(pMat, pStr0, type, index, pOut, pMax);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ref byte pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] double* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				fixed (byte* ppKey = &pKey)
				{
					AiReturn ret = GetMaterialFloatArrayNative((AiMaterial*)ppMat, (byte*)ppKey, type, index, pOut, pMax);
					return ret;
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] double* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				fixed (byte* ppKey = pKey)
				{
					AiReturn ret = GetMaterialFloatArrayNative((AiMaterial*)ppMat, (byte*)ppKey, type, index, pOut, pMax);
					return ret;
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] string pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] double* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pKey != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pKey);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pKey, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AiReturn ret = GetMaterialFloatArrayNative((AiMaterial*)ppMat, pStr0, type, index, pOut, pMax);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] byte* pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] ref double pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			fixed (double* ppOut = &pOut)
			{
				AiReturn ret = GetMaterialFloatArrayNative(pMat, pKey, type, index, (double*)ppOut, pMax);
				return ret;
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] byte* pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] ref double pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				fixed (double* ppOut = &pOut)
				{
					AiReturn ret = GetMaterialFloatArrayNative((AiMaterial*)ppMat, pKey, type, index, (double*)ppOut, pMax);
					return ret;
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ref byte pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] ref double pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			fixed (byte* ppKey = &pKey)
			{
				fixed (double* ppOut = &pOut)
				{
					AiReturn ret = GetMaterialFloatArrayNative(pMat, (byte*)ppKey, type, index, (double*)ppOut, pMax);
					return ret;
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] ref double pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			fixed (byte* ppKey = pKey)
			{
				fixed (double* ppOut = &pOut)
				{
					AiReturn ret = GetMaterialFloatArrayNative(pMat, (byte*)ppKey, type, index, (double*)ppOut, pMax);
					return ret;
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] string pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] ref double pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pKey != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pKey);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pKey, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (double* ppOut = &pOut)
			{
				AiReturn ret = GetMaterialFloatArrayNative(pMat, pStr0, type, index, (double*)ppOut, pMax);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ref byte pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] ref double pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				fixed (byte* ppKey = &pKey)
				{
					fixed (double* ppOut = &pOut)
					{
						AiReturn ret = GetMaterialFloatArrayNative((AiMaterial*)ppMat, (byte*)ppKey, type, index, (double*)ppOut, pMax);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] ref double pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				fixed (byte* ppKey = pKey)
				{
					fixed (double* ppOut = &pOut)
					{
						AiReturn ret = GetMaterialFloatArrayNative((AiMaterial*)ppMat, (byte*)ppKey, type, index, (double*)ppOut, pMax);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] string pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] ref double pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pKey != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pKey);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pKey, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (double* ppOut = &pOut)
				{
					AiReturn ret = GetMaterialFloatArrayNative((AiMaterial*)ppMat, pStr0, type, index, (double*)ppOut, pMax);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] byte* pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] double* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			fixed (uint* ppMax = &pMax)
			{
				AiReturn ret = GetMaterialFloatArrayNative(pMat, pKey, type, index, pOut, (uint*)ppMax);
				return ret;
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] byte* pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] double* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				fixed (uint* ppMax = &pMax)
				{
					AiReturn ret = GetMaterialFloatArrayNative((AiMaterial*)ppMat, pKey, type, index, pOut, (uint*)ppMax);
					return ret;
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ref byte pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] double* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			fixed (byte* ppKey = &pKey)
			{
				fixed (uint* ppMax = &pMax)
				{
					AiReturn ret = GetMaterialFloatArrayNative(pMat, (byte*)ppKey, type, index, pOut, (uint*)ppMax);
					return ret;
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] double* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			fixed (byte* ppKey = pKey)
			{
				fixed (uint* ppMax = &pMax)
				{
					AiReturn ret = GetMaterialFloatArrayNative(pMat, (byte*)ppKey, type, index, pOut, (uint*)ppMax);
					return ret;
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] string pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] double* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pKey != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pKey);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pKey, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (uint* ppMax = &pMax)
			{
				AiReturn ret = GetMaterialFloatArrayNative(pMat, pStr0, type, index, pOut, (uint*)ppMax);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ref byte pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] double* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				fixed (byte* ppKey = &pKey)
				{
					fixed (uint* ppMax = &pMax)
					{
						AiReturn ret = GetMaterialFloatArrayNative((AiMaterial*)ppMat, (byte*)ppKey, type, index, pOut, (uint*)ppMax);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] double* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				fixed (byte* ppKey = pKey)
				{
					fixed (uint* ppMax = &pMax)
					{
						AiReturn ret = GetMaterialFloatArrayNative((AiMaterial*)ppMat, (byte*)ppKey, type, index, pOut, (uint*)ppMax);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] string pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] double* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pKey != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pKey);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pKey, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (uint* ppMax = &pMax)
				{
					AiReturn ret = GetMaterialFloatArrayNative((AiMaterial*)ppMat, pStr0, type, index, pOut, (uint*)ppMax);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] byte* pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] ref double pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			fixed (double* ppOut = &pOut)
			{
				fixed (uint* ppMax = &pMax)
				{
					AiReturn ret = GetMaterialFloatArrayNative(pMat, pKey, type, index, (double*)ppOut, (uint*)ppMax);
					return ret;
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] byte* pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] ref double pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				fixed (double* ppOut = &pOut)
				{
					fixed (uint* ppMax = &pMax)
					{
						AiReturn ret = GetMaterialFloatArrayNative((AiMaterial*)ppMat, pKey, type, index, (double*)ppOut, (uint*)ppMax);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ref byte pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] ref double pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			fixed (byte* ppKey = &pKey)
			{
				fixed (double* ppOut = &pOut)
				{
					fixed (uint* ppMax = &pMax)
					{
						AiReturn ret = GetMaterialFloatArrayNative(pMat, (byte*)ppKey, type, index, (double*)ppOut, (uint*)ppMax);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] ref double pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			fixed (byte* ppKey = pKey)
			{
				fixed (double* ppOut = &pOut)
				{
					fixed (uint* ppMax = &pMax)
					{
						AiReturn ret = GetMaterialFloatArrayNative(pMat, (byte*)ppKey, type, index, (double*)ppOut, (uint*)ppMax);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] string pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] ref double pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pKey != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pKey);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pKey, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (double* ppOut = &pOut)
			{
				fixed (uint* ppMax = &pMax)
				{
					AiReturn ret = GetMaterialFloatArrayNative(pMat, pStr0, type, index, (double*)ppOut, (uint*)ppMax);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ref byte pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] ref double pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				fixed (byte* ppKey = &pKey)
				{
					fixed (double* ppOut = &pOut)
					{
						fixed (uint* ppMax = &pMax)
						{
							AiReturn ret = GetMaterialFloatArrayNative((AiMaterial*)ppMat, (byte*)ppKey, type, index, (double*)ppOut, (uint*)ppMax);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] ref double pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				fixed (byte* ppKey = pKey)
				{
					fixed (double* ppOut = &pOut)
					{
						fixed (uint* ppMax = &pMax)
						{
							AiReturn ret = GetMaterialFloatArrayNative((AiMaterial*)ppMat, (byte*)ppKey, type, index, (double*)ppOut, (uint*)ppMax);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the<br/>
		/// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)<br/>
		/// <br/>
		/// <br/>
		/// ---------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialFloatArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialFloatArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] string pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ai_real *")] ref double pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pKey != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pKey);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pKey, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (double* ppOut = &pOut)
				{
					fixed (uint* ppMax = &pMax)
					{
						AiReturn ret = GetMaterialFloatArrayNative((AiMaterial*)ppMat, pStr0, type, index, (double*)ppOut, (uint*)ppMax);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static AiReturn GetMaterialIntegerArrayNative([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] byte* pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] int* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<AiMaterial*, byte*, uint, uint, int*, uint*, AiReturn>)funcTable[116])(pMat, pKey, type, index, pOut, pMax);
			#else
			return (AiReturn)((delegate* unmanaged[Cdecl]<nint, nint, uint, uint, nint, nint, AiReturn>)funcTable[116])((nint)pMat, (nint)pKey, type, index, (nint)pOut, (nint)pMax);
			#endif
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] byte* pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] int* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			AiReturn ret = GetMaterialIntegerArrayNative(pMat, pKey, type, index, pOut, pMax);
			return ret;
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] byte* pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] int* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				AiReturn ret = GetMaterialIntegerArrayNative((AiMaterial*)ppMat, pKey, type, index, pOut, pMax);
				return ret;
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ref byte pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] int* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			fixed (byte* ppKey = &pKey)
			{
				AiReturn ret = GetMaterialIntegerArrayNative(pMat, (byte*)ppKey, type, index, pOut, pMax);
				return ret;
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] int* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			fixed (byte* ppKey = pKey)
			{
				AiReturn ret = GetMaterialIntegerArrayNative(pMat, (byte*)ppKey, type, index, pOut, pMax);
				return ret;
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] string pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] int* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pKey != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pKey);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pKey, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AiReturn ret = GetMaterialIntegerArrayNative(pMat, pStr0, type, index, pOut, pMax);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ref byte pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] int* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				fixed (byte* ppKey = &pKey)
				{
					AiReturn ret = GetMaterialIntegerArrayNative((AiMaterial*)ppMat, (byte*)ppKey, type, index, pOut, pMax);
					return ret;
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] int* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				fixed (byte* ppKey = pKey)
				{
					AiReturn ret = GetMaterialIntegerArrayNative((AiMaterial*)ppMat, (byte*)ppKey, type, index, pOut, pMax);
					return ret;
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] string pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] int* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pKey != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pKey);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pKey, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AiReturn ret = GetMaterialIntegerArrayNative((AiMaterial*)ppMat, pStr0, type, index, pOut, pMax);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] byte* pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] ref int pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			fixed (int* ppOut = &pOut)
			{
				AiReturn ret = GetMaterialIntegerArrayNative(pMat, pKey, type, index, (int*)ppOut, pMax);
				return ret;
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] byte* pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] ref int pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				fixed (int* ppOut = &pOut)
				{
					AiReturn ret = GetMaterialIntegerArrayNative((AiMaterial*)ppMat, pKey, type, index, (int*)ppOut, pMax);
					return ret;
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ref byte pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] ref int pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			fixed (byte* ppKey = &pKey)
			{
				fixed (int* ppOut = &pOut)
				{
					AiReturn ret = GetMaterialIntegerArrayNative(pMat, (byte*)ppKey, type, index, (int*)ppOut, pMax);
					return ret;
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] ref int pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			fixed (byte* ppKey = pKey)
			{
				fixed (int* ppOut = &pOut)
				{
					AiReturn ret = GetMaterialIntegerArrayNative(pMat, (byte*)ppKey, type, index, (int*)ppOut, pMax);
					return ret;
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] string pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] ref int pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pKey != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pKey);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pKey, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* ppOut = &pOut)
			{
				AiReturn ret = GetMaterialIntegerArrayNative(pMat, pStr0, type, index, (int*)ppOut, pMax);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ref byte pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] ref int pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				fixed (byte* ppKey = &pKey)
				{
					fixed (int* ppOut = &pOut)
					{
						AiReturn ret = GetMaterialIntegerArrayNative((AiMaterial*)ppMat, (byte*)ppKey, type, index, (int*)ppOut, pMax);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] ref int pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				fixed (byte* ppKey = pKey)
				{
					fixed (int* ppOut = &pOut)
					{
						AiReturn ret = GetMaterialIntegerArrayNative((AiMaterial*)ppMat, (byte*)ppKey, type, index, (int*)ppOut, pMax);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] string pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] ref int pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pKey != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pKey);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pKey, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (int* ppOut = &pOut)
				{
					AiReturn ret = GetMaterialIntegerArrayNative((AiMaterial*)ppMat, pStr0, type, index, (int*)ppOut, pMax);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] byte* pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] int* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			fixed (uint* ppMax = &pMax)
			{
				AiReturn ret = GetMaterialIntegerArrayNative(pMat, pKey, type, index, pOut, (uint*)ppMax);
				return ret;
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] byte* pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] int* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				fixed (uint* ppMax = &pMax)
				{
					AiReturn ret = GetMaterialIntegerArrayNative((AiMaterial*)ppMat, pKey, type, index, pOut, (uint*)ppMax);
					return ret;
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ref byte pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] int* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			fixed (byte* ppKey = &pKey)
			{
				fixed (uint* ppMax = &pMax)
				{
					AiReturn ret = GetMaterialIntegerArrayNative(pMat, (byte*)ppKey, type, index, pOut, (uint*)ppMax);
					return ret;
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] int* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			fixed (byte* ppKey = pKey)
			{
				fixed (uint* ppMax = &pMax)
				{
					AiReturn ret = GetMaterialIntegerArrayNative(pMat, (byte*)ppKey, type, index, pOut, (uint*)ppMax);
					return ret;
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] string pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] int* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pKey != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pKey);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pKey, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (uint* ppMax = &pMax)
			{
				AiReturn ret = GetMaterialIntegerArrayNative(pMat, pStr0, type, index, pOut, (uint*)ppMax);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ref byte pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] int* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				fixed (byte* ppKey = &pKey)
				{
					fixed (uint* ppMax = &pMax)
					{
						AiReturn ret = GetMaterialIntegerArrayNative((AiMaterial*)ppMat, (byte*)ppKey, type, index, pOut, (uint*)ppMax);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] int* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				fixed (byte* ppKey = pKey)
				{
					fixed (uint* ppMax = &pMax)
					{
						AiReturn ret = GetMaterialIntegerArrayNative((AiMaterial*)ppMat, (byte*)ppKey, type, index, pOut, (uint*)ppMax);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] string pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] int* pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (pKey != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(pKey);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(pKey, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (uint* ppMax = &pMax)
				{
					AiReturn ret = GetMaterialIntegerArrayNative((AiMaterial*)ppMat, pStr0, type, index, pOut, (uint*)ppMax);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] byte* pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] ref int pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			fixed (int* ppOut = &pOut)
			{
				fixed (uint* ppMax = &pMax)
				{
					AiReturn ret = GetMaterialIntegerArrayNative(pMat, pKey, type, index, (int*)ppOut, (uint*)ppMax);
					return ret;
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] byte* pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] ref int pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				fixed (int* ppOut = &pOut)
				{
					fixed (uint* ppMax = &pMax)
					{
						AiReturn ret = GetMaterialIntegerArrayNative((AiMaterial*)ppMat, pKey, type, index, (int*)ppOut, (uint*)ppMax);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ref byte pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] ref int pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			fixed (byte* ppKey = &pKey)
			{
				fixed (int* ppOut = &pOut)
				{
					fixed (uint* ppMax = &pMax)
					{
						AiReturn ret = GetMaterialIntegerArrayNative(pMat, (byte*)ppKey, type, index, (int*)ppOut, (uint*)ppMax);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] ref int pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			fixed (byte* ppKey = pKey)
			{
				fixed (int* ppOut = &pOut)
				{
					fixed (uint* ppMax = &pMax)
					{
						AiReturn ret = GetMaterialIntegerArrayNative(pMat, (byte*)ppKey, type, index, (int*)ppOut, (uint*)ppMax);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] AiMaterial* pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] string pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] ref int pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pKey != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pKey);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pKey, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* ppOut = &pOut)
			{
				fixed (uint* ppMax = &pMax)
				{
					AiReturn ret = GetMaterialIntegerArrayNative(pMat, pStr0, type, index, (int*)ppOut, (uint*)ppMax);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ref byte pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] ref int pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				fixed (byte* ppKey = &pKey)
				{
					fixed (int* ppOut = &pOut)
					{
						fixed (uint* ppMax = &pMax)
						{
							AiReturn ret = GetMaterialIntegerArrayNative((AiMaterial*)ppMat, (byte*)ppKey, type, index, (int*)ppOut, (uint*)ppMax);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// ---------------------------------------------------------------------------<br/>
		/// <br/>
		/// See the sample for aiGetMaterialFloatArray for more information.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "aiGetMaterialIntegerArray")]
		[return: NativeName(NativeNameType.Type, "aiReturn")]
		public static AiReturn GetMaterialIntegerArray([NativeName(NativeNameType.Param, "pMat")] [NativeName(NativeNameType.Type, "aiMaterial const *")] ref AiMaterial pMat, [NativeName(NativeNameType.Param, "pKey")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pKey, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "unsigned int")] uint type, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "unsigned int")] uint index, [NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "int *")] ref int pOut, [NativeName(NativeNameType.Param, "pMax")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint pMax)
		{
			fixed (AiMaterial* ppMat = &pMat)
			{
				fixed (byte* ppKey = pKey)
				{
					fixed (int* ppOut = &pOut)
					{
						fixed (uint* ppMax = &pMax)
						{
							AiReturn ret = GetMaterialIntegerArrayNative((AiMaterial*)ppMat, (byte*)ppKey, type, index, (int*)ppOut, (uint*)ppMax);
							return ret;
						}
					}
				}
			}
		}
	}
}
