// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.Assimp
{
	/// <summary>
	/// ---------------------------------------------------------------------------<br/>
	/// <br/>
	/// As an user, you'll probably never need to deal with this data structure.<br/>
	/// Just use the provided aiGetMaterialXXX() or aiMaterial::Get() family<br/>
	/// of functions to query material properties easily. Processing them<br/>
	/// manually is faster, but it is not the recommended way. It isn't worth<br/>
	/// the effort. <br/>
	/// Material property names follow a simple scheme:<br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "aiMaterialProperty")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct AiMaterialProperty
	{
		/// <summary>
		/// Specifies the name of the property (key)<br/>
		/// Keys are generally case insensitive.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "mKey")]
		[NativeName(NativeNameType.Type, "aiString")]
		public AiString MKey;

		/// <summary>
		/// Textures: Specifies their exact usage semantic.<br/>
		/// For non-texture properties, this member is always 0<br/>
		/// (or, better-said, #aiTextureType_NONE).<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "mSemantic")]
		[NativeName(NativeNameType.Type, "unsigned int")]
		public uint MSemantic;

		/// <summary>
		/// Textures: Specifies the index of the texture.<br/>
		/// For non-texture properties, this member is always 0.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "mIndex")]
		[NativeName(NativeNameType.Type, "unsigned int")]
		public uint MIndex;

		/// <summary>
		/// Size of the buffer mData is pointing to, in bytes.<br/>
		/// This value may not be 0.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "mDataLength")]
		[NativeName(NativeNameType.Type, "unsigned int")]
		public uint MDataLength;

		/// <summary>
		/// Type information for the property.<br/>
		/// Defines the data layout inside the data buffer. This is used<br/>
		/// by the library internally to perform debug checks and to<br/>
		/// utilize proper type conversions.<br/>
		/// (It's probably a hacky solution, but it works.)<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "mType")]
		[NativeName(NativeNameType.Type, "aiPropertyTypeInfo")]
		public AiPropertyTypeInfo MType;

		/// <summary>
		/// Binary buffer to hold the property's value.<br/>
		/// The size of the buffer is always mDataLength.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "mData")]
		[NativeName(NativeNameType.Type, "char *")]
		public unsafe byte* MData;


		public unsafe AiMaterialProperty(AiString mKey = default, uint mSemantic = default, uint mIndex = default, uint mDataLength = default, AiPropertyTypeInfo mType = default, byte* mData = default)
		{
			MKey = mKey;
			MSemantic = mSemantic;
			MIndex = mIndex;
			MDataLength = mDataLength;
			MType = mType;
			MData = mData;
		}


	}

}
