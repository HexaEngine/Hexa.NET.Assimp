// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.Assimp
{
	/// <summary>
	/// ---------------------------------------------------------------------------<br/>
	/// <br/>
	/// It usually consists of a number of vertices and a series of primitives/faces<br/>
	/// referencing the vertices. In addition there might be a series of bones, each<br/>
	/// of them addressing a number of vertices with a certain weight. Vertex data<br/>
	/// is presented in channels with each channel containing a single per-vertex<br/>
	/// information such as a set of texture coordinates or a normal vector.<br/>
	/// If a data pointer is non-null, the corresponding data stream is present.<br/>
	/// From C++-programs you can also use the comfort functions Has*() to<br/>
	/// test for the presence of various data streams.<br/>
	/// A Mesh uses only a single material which is referenced by a material ID.<br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "aiMesh")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct AiMesh
	{
		/// <summary>
		/// Bitwise combination of the members of the #aiPrimitiveType enum.<br/>
		/// This specifies which types of primitives are present in the mesh.<br/>
		/// The "SortByPrimitiveType"-Step can be used to make sure the<br/>
		/// output meshes consist of one primitive type each.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "mPrimitiveTypes")]
		[NativeName(NativeNameType.Type, "unsigned int")]
		public uint MPrimitiveTypes;

		/// <summary>
		/// The number of vertices in this mesh.<br/>
		/// This is also the size of all of the per-vertex data arrays.<br/>
		/// The maximum value for this member is #AI_MAX_VERTICES.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "mNumVertices")]
		[NativeName(NativeNameType.Type, "unsigned int")]
		public uint MNumVertices;

		/// <summary>
		/// The number of primitives (triangles, polygons, lines) in this  mesh.<br/>
		/// This is also the size of the mFaces array.<br/>
		/// The maximum value for this member is #AI_MAX_FACES.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "mNumFaces")]
		[NativeName(NativeNameType.Type, "unsigned int")]
		public uint MNumFaces;

		/// <summary>
		/// <br/>
		/// This array is always present in a mesh. The array is<br/>
		/// mNumVertices in size.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "mVertices")]
		[NativeName(NativeNameType.Type, "aiVector3D *")]
		public unsafe Vector3* MVertices;

		/// <summary>
		/// <br/>
		/// The array contains normalized vectors, nullptr if not present.<br/>
		/// The array is mNumVertices in size. Normals are undefined for<br/>
		/// point and line primitives. A mesh consisting of points and<br/>
		/// lines only may not have normal vectors. Meshes with mixed<br/>
		/// primitive types (i.e. lines and triangles) may have normals,<br/>
		/// but the normals for vertices that are only referenced by<br/>
		/// point or line primitives are undefined and set to QNaN (WARN:<br/>
		/// qNaN compares to inequal to *everything*, even to qNaN itself.<br/>
		/// Using code like this to check whether a field is qnan is:<br/>
		/// <br/>
		/// still dangerous because even 1.f == 1.f could evaluate to false! (<br/>
		/// remember the subtleties of IEEE754 artithmetics). Use stuff like<br/>
		/// <br/>
		/// instead.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "mNormals")]
		[NativeName(NativeNameType.Type, "aiVector3D *")]
		public unsafe Vector3* MNormals;

		/// <summary>
		/// <br/>
		/// The tangent of a vertex points in the direction of the positive<br/>
		/// X texture axis. The array contains normalized vectors, nullptr if<br/>
		/// not present. The array is mNumVertices in size. A mesh consisting<br/>
		/// of points and lines only may not have normal vectors. Meshes with<br/>
		/// mixed primitive types (i.e. lines and triangles) may have<br/>
		/// normals, but the normals for vertices that are only referenced by<br/>
		/// point or line primitives are undefined and set to qNaN.  See<br/>
		/// the #mNormals member for a detailed discussion of qNaNs.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "mTangents")]
		[NativeName(NativeNameType.Type, "aiVector3D *")]
		public unsafe Vector3* MTangents;

		/// <summary>
		/// <br/>
		/// The bitangent of a vertex points in the direction of the positive<br/>
		/// Y texture axis. The array contains normalized vectors, nullptr if not<br/>
		/// present. The array is mNumVertices in size.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "mBitangents")]
		[NativeName(NativeNameType.Type, "aiVector3D *")]
		public unsafe Vector3* MBitangents;

		/// <summary>
		/// <br/>
		/// A mesh may contain 0 to #AI_MAX_NUMBER_OF_COLOR_SETS vertex<br/>
		/// colors per vertex. nullptr if not present. Each array is<br/>
		/// mNumVertices in size if present.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "mColors")]
		[NativeName(NativeNameType.Type, "aiColor4D *[8]")]
		public unsafe Vector4* MColors_0;
		public unsafe Vector4* MColors_1;
		public unsafe Vector4* MColors_2;
		public unsafe Vector4* MColors_3;
		public unsafe Vector4* MColors_4;
		public unsafe Vector4* MColors_5;
		public unsafe Vector4* MColors_6;
		public unsafe Vector4* MColors_7;

		/// <summary>
		/// <br/>
		/// A mesh may contain 0 to AI_MAX_NUMBER_OF_TEXTURECOORDS channels per<br/>
		/// vertex. Used and unused (nullptr) channels may go in any order.<br/>
		/// The array is mNumVertices in size.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "mTextureCoords")]
		[NativeName(NativeNameType.Type, "aiVector3D *[8]")]
		public unsafe Vector3* MTextureCoords_0;
		public unsafe Vector3* MTextureCoords_1;
		public unsafe Vector3* MTextureCoords_2;
		public unsafe Vector3* MTextureCoords_3;
		public unsafe Vector3* MTextureCoords_4;
		public unsafe Vector3* MTextureCoords_5;
		public unsafe Vector3* MTextureCoords_6;
		public unsafe Vector3* MTextureCoords_7;

		/// <summary>
		/// <br/>
		/// Up to three channels are supported (UVW, for accessing volume<br/>
		/// or cube maps). If the value is 2 for a given channel n, the<br/>
		/// component p.z of mTextureCoords[n][p] is set to 0.0f.<br/>
		/// If the value is 1 for a given channel, p.y is set to 0.0f, too.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "mNumUVComponents")]
		[NativeName(NativeNameType.Type, "unsigned int[8]")]
		public uint MNumUVComponents_0;
		public uint MNumUVComponents_1;
		public uint MNumUVComponents_2;
		public uint MNumUVComponents_3;
		public uint MNumUVComponents_4;
		public uint MNumUVComponents_5;
		public uint MNumUVComponents_6;
		public uint MNumUVComponents_7;

		/// <summary>
		/// <br/>
		/// Each face refers to a number of vertices by their indices.<br/>
		/// This array is always present in a mesh, its size is given<br/>
		/// in mNumFaces. If the #AI_SCENE_FLAGS_NON_VERBOSE_FORMAT<br/>
		/// is NOT set each face references an unique set of vertices.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "mFaces")]
		[NativeName(NativeNameType.Type, "aiFace *")]
		public unsafe AiFace* MFaces;

		/// <summary>
		/// The number of bones this mesh contains. Can be 0, in which case the mBones array is nullptr.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "mNumBones")]
		[NativeName(NativeNameType.Type, "unsigned int")]
		public uint MNumBones;

		/// <summary>
		/// <br/>
		/// A bone consists of a name by which it can be found in the<br/>
		/// frame hierarchy and a set of vertex weights.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "mBones")]
		[NativeName(NativeNameType.Type, "aiBone * *")]
		public unsafe AiBone** MBones;

		/// <summary>
		/// <br/>
		/// A mesh uses only a single material. If an imported model uses<br/>
		/// multiple materials, the import splits up the mesh. Use this value<br/>
		/// as index into the scene's material list.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "mMaterialIndex")]
		[NativeName(NativeNameType.Type, "unsigned int")]
		public uint MMaterialIndex;

		/// <summary>
		/// Name of the mesh. Meshes can be named, but this is not a<br/>
		/// requirement and leaving this field empty is totally fine.<br/>
		/// There are mainly three uses for mesh names:<br/>
		/// - some formats name nodes and meshes independently.<br/>
		/// - importers tend to split meshes up to meet the<br/>
		/// one-material-per-mesh requirement. Assigning<br/>
		/// the same (dummy) name to each of the result meshes<br/>
		/// aids the caller at recovering the original mesh<br/>
		/// partitioning.<br/>
		/// - Vertex animations refer to meshes by their names.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "mName")]
		[NativeName(NativeNameType.Type, "aiString")]
		public AiString MName;

		/// <summary>
		/// The number of attachment meshes.<br/>
		/// Currently known to work with loaders:<br/>
		/// - Collada<br/>
		/// - gltf<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "mNumAnimMeshes")]
		[NativeName(NativeNameType.Type, "unsigned int")]
		public uint MNumAnimMeshes;

		/// <summary>
		/// Attachment meshes for this mesh, for vertex-based animation.<br/>
		/// Attachment meshes carry replacement data for some of the<br/>
		/// mesh'es vertex components (usually positions, normals).<br/>
		/// Currently known to work with loaders:<br/>
		/// - Collada<br/>
		/// - gltf<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "mAnimMeshes")]
		[NativeName(NativeNameType.Type, "aiAnimMesh * *")]
		public unsafe AiAnimMesh** MAnimMeshes;

		/// <summary>
		/// Method of morphing when anim-meshes are specified.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "mMethod")]
		[NativeName(NativeNameType.Type, "aiMorphingMethod")]
		public AiMorphingMethod MMethod;

		/// <summary>
		/// The bounding box.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "mAABB")]
		[NativeName(NativeNameType.Type, "aiAABB")]
		public AiAABB MAABB;

		/// <summary>
		/// Vertex UV stream names. Pointer to array of size AI_MAX_NUMBER_OF_TEXTURECOORDS<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "mTextureCoordsNames")]
		[NativeName(NativeNameType.Type, "aiString * *")]
		public unsafe AiString** MTextureCoordsNames;


		public unsafe AiMesh(uint mPrimitiveTypes = default, uint mNumVertices = default, uint mNumFaces = default, Vector3* mVertices = default, Vector3* mNormals = default, Vector3* mTangents = default, Vector3* mBitangents = default, Vector4** mColors = default, Vector3** mTextureCoords = default, uint* mNumUVComponents = default, AiFace* mFaces = default, uint mNumBones = default, AiBone** mBones = default, uint mMaterialIndex = default, AiString mName = default, uint mNumAnimMeshes = default, AiAnimMesh** mAnimMeshes = default, AiMorphingMethod mMethod = default, AiAABB maAbb = default, AiString** mTextureCoordsNames = default)
		{
			MPrimitiveTypes = mPrimitiveTypes;
			MNumVertices = mNumVertices;
			MNumFaces = mNumFaces;
			MVertices = mVertices;
			MNormals = mNormals;
			MTangents = mTangents;
			MBitangents = mBitangents;
			if (mColors != default(Vector4**))
			{
				MColors_0 = mColors[0];
				MColors_1 = mColors[1];
				MColors_2 = mColors[2];
				MColors_3 = mColors[3];
				MColors_4 = mColors[4];
				MColors_5 = mColors[5];
				MColors_6 = mColors[6];
				MColors_7 = mColors[7];
			}
			if (mTextureCoords != default(Vector3**))
			{
				MTextureCoords_0 = mTextureCoords[0];
				MTextureCoords_1 = mTextureCoords[1];
				MTextureCoords_2 = mTextureCoords[2];
				MTextureCoords_3 = mTextureCoords[3];
				MTextureCoords_4 = mTextureCoords[4];
				MTextureCoords_5 = mTextureCoords[5];
				MTextureCoords_6 = mTextureCoords[6];
				MTextureCoords_7 = mTextureCoords[7];
			}
			if (mNumUVComponents != default(uint*))
			{
				MNumUVComponents_0 = mNumUVComponents[0];
				MNumUVComponents_1 = mNumUVComponents[1];
				MNumUVComponents_2 = mNumUVComponents[2];
				MNumUVComponents_3 = mNumUVComponents[3];
				MNumUVComponents_4 = mNumUVComponents[4];
				MNumUVComponents_5 = mNumUVComponents[5];
				MNumUVComponents_6 = mNumUVComponents[6];
				MNumUVComponents_7 = mNumUVComponents[7];
			}
			MFaces = mFaces;
			MNumBones = mNumBones;
			MBones = mBones;
			MMaterialIndex = mMaterialIndex;
			MName = mName;
			MNumAnimMeshes = mNumAnimMeshes;
			MAnimMeshes = mAnimMeshes;
			MMethod = mMethod;
			MAABB = maAbb;
			MTextureCoordsNames = mTextureCoordsNames;
		}

		public unsafe AiMesh(uint mPrimitiveTypes = default, uint mNumVertices = default, uint mNumFaces = default, Vector3* mVertices = default, Vector3* mNormals = default, Vector3* mTangents = default, Vector3* mBitangents = default, Span<Pointer<Vector4>> mColors = default, Span<Pointer<Vector3>> mTextureCoords = default, Span<uint> mNumUVComponents = default, AiFace* mFaces = default, uint mNumBones = default, AiBone** mBones = default, uint mMaterialIndex = default, AiString mName = default, uint mNumAnimMeshes = default, AiAnimMesh** mAnimMeshes = default, AiMorphingMethod mMethod = default, AiAABB maAbb = default, AiString** mTextureCoordsNames = default)
		{
			MPrimitiveTypes = mPrimitiveTypes;
			MNumVertices = mNumVertices;
			MNumFaces = mNumFaces;
			MVertices = mVertices;
			MNormals = mNormals;
			MTangents = mTangents;
			MBitangents = mBitangents;
			if (mColors != default(Span<Pointer<Vector4>>))
			{
				MColors_0 = mColors[0];
				MColors_1 = mColors[1];
				MColors_2 = mColors[2];
				MColors_3 = mColors[3];
				MColors_4 = mColors[4];
				MColors_5 = mColors[5];
				MColors_6 = mColors[6];
				MColors_7 = mColors[7];
			}
			if (mTextureCoords != default(Span<Pointer<Vector3>>))
			{
				MTextureCoords_0 = mTextureCoords[0];
				MTextureCoords_1 = mTextureCoords[1];
				MTextureCoords_2 = mTextureCoords[2];
				MTextureCoords_3 = mTextureCoords[3];
				MTextureCoords_4 = mTextureCoords[4];
				MTextureCoords_5 = mTextureCoords[5];
				MTextureCoords_6 = mTextureCoords[6];
				MTextureCoords_7 = mTextureCoords[7];
			}
			if (mNumUVComponents != default(Span<uint>))
			{
				MNumUVComponents_0 = mNumUVComponents[0];
				MNumUVComponents_1 = mNumUVComponents[1];
				MNumUVComponents_2 = mNumUVComponents[2];
				MNumUVComponents_3 = mNumUVComponents[3];
				MNumUVComponents_4 = mNumUVComponents[4];
				MNumUVComponents_5 = mNumUVComponents[5];
				MNumUVComponents_6 = mNumUVComponents[6];
				MNumUVComponents_7 = mNumUVComponents[7];
			}
			MFaces = mFaces;
			MNumBones = mNumBones;
			MBones = mBones;
			MMaterialIndex = mMaterialIndex;
			MName = mName;
			MNumAnimMeshes = mNumAnimMeshes;
			MAnimMeshes = mAnimMeshes;
			MMethod = mMethod;
			MAABB = maAbb;
			MTextureCoordsNames = mTextureCoordsNames;
		}


		/// <summary>
		/// <br/>
		/// A mesh may contain 0 to #AI_MAX_NUMBER_OF_COLOR_SETS vertex<br/>
		/// colors per vertex. nullptr if not present. Each array is<br/>
		/// mNumVertices in size if present.<br/>
		/// </summary>
		public unsafe Span<Pointer<Vector4>> MColors
		
		{
			get
			{
				fixed (Vector4** p = &this.MColors_0)
				{
					return new Span<Pointer<Vector4>>(p, 8);
				}
			}
		}
		/// <summary>
		/// <br/>
		/// A mesh may contain 0 to AI_MAX_NUMBER_OF_TEXTURECOORDS channels per<br/>
		/// vertex. Used and unused (nullptr) channels may go in any order.<br/>
		/// The array is mNumVertices in size.<br/>
		/// </summary>
		public unsafe Span<Pointer<Vector3>> MTextureCoords
		
		{
			get
			{
				fixed (Vector3** p = &this.MTextureCoords_0)
				{
					return new Span<Pointer<Vector3>>(p, 8);
				}
			}
		}
	}

}
