// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.Assimp
{
	/// <summary>
	/// --------------------------------------------------------------------------------<br/>
	/// Helper structure to describe an embedded texture<br/>
	/// Normally textures are contained in external files but some file formats embed<br/>
	/// them directly in the model file. There are two types of embedded textures:<br/>
	/// 1. Uncompressed textures. The color data is given in an uncompressed format.<br/>
	/// 2. Compressed textures stored in a file format like png or jpg. The raw file<br/>
	/// bytes are given so the application must utilize an image decoder (e.g. DevIL) to<br/>
	/// get access to the actual color data.<br/>
	/// Embedded textures are referenced from materials using strings like "*0", "*1", etc.<br/>
	/// as the texture paths (a single asterisk character followed by the<br/>
	/// zero-based index of the texture in the aiScene::mTextures array).<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "aiTexture")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct AiTexture
	{
		/// <summary>
		/// Width of the texture, in pixels<br/>
		/// If mHeight is zero the texture is compressed in a format<br/>
		/// like JPEG. In this case mWidth specifies the size of the<br/>
		/// memory area pcData is pointing to, in bytes.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "mWidth")]
		[NativeName(NativeNameType.Type, "unsigned int")]
		public uint MWidth;

		/// <summary>
		/// Height of the texture, in pixels<br/>
		/// If this value is zero, pcData points to an compressed texture<br/>
		/// in any format (e.g. JPEG).<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "mHeight")]
		[NativeName(NativeNameType.Type, "unsigned int")]
		public uint MHeight;

		/// <summary>
		/// 8 for string + 1 for terminator.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "achFormatHint")]
		[NativeName(NativeNameType.Type, "char[9]")]
		public byte AchFormatHint_0;
		public byte AchFormatHint_1;
		public byte AchFormatHint_2;
		public byte AchFormatHint_3;
		public byte AchFormatHint_4;
		public byte AchFormatHint_5;
		public byte AchFormatHint_6;
		public byte AchFormatHint_7;
		public byte AchFormatHint_8;

		/// <summary>
		/// Data of the texture.<br/>
		/// Points to an array of mWidth * mHeight aiTexel's.<br/>
		/// The format of the texture data shall always be ARGB8888 if the texture-hint of the type is empty.<br/>
		/// If the hint is not empty you can interpret the format by looking into this hint.<br/>
		/// make the implementation for user of the library as easy<br/>
		/// as possible. If mHeight = 0 this is a pointer to a memory<br/>
		/// buffer of size mWidth containing the compressed texture<br/>
		/// data. Good luck, have fun!<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pcData")]
		[NativeName(NativeNameType.Type, "aiTexel *")]
		public unsafe AiTexel* PcData;

		/// <summary>
		/// Texture original filename<br/>
		/// Used to get the texture reference<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "mFilename")]
		[NativeName(NativeNameType.Type, "aiString")]
		public AiString MFilename;


		public unsafe AiTexture(uint mWidth = default, uint mHeight = default, byte* achFormatHint = default, AiTexel* pcData = default, AiString mFilename = default)
		{
			MWidth = mWidth;
			MHeight = mHeight;
			if (achFormatHint != default(byte*))
			{
				AchFormatHint_0 = achFormatHint[0];
				AchFormatHint_1 = achFormatHint[1];
				AchFormatHint_2 = achFormatHint[2];
				AchFormatHint_3 = achFormatHint[3];
				AchFormatHint_4 = achFormatHint[4];
				AchFormatHint_5 = achFormatHint[5];
				AchFormatHint_6 = achFormatHint[6];
				AchFormatHint_7 = achFormatHint[7];
				AchFormatHint_8 = achFormatHint[8];
			}
			PcData = pcData;
			MFilename = mFilename;
		}

		public unsafe AiTexture(uint mWidth = default, uint mHeight = default, Span<byte> achFormatHint = default, AiTexel* pcData = default, AiString mFilename = default)
		{
			MWidth = mWidth;
			MHeight = mHeight;
			if (achFormatHint != default(Span<byte>))
			{
				AchFormatHint_0 = achFormatHint[0];
				AchFormatHint_1 = achFormatHint[1];
				AchFormatHint_2 = achFormatHint[2];
				AchFormatHint_3 = achFormatHint[3];
				AchFormatHint_4 = achFormatHint[4];
				AchFormatHint_5 = achFormatHint[5];
				AchFormatHint_6 = achFormatHint[6];
				AchFormatHint_7 = achFormatHint[7];
				AchFormatHint_8 = achFormatHint[8];
			}
			PcData = pcData;
			MFilename = mFilename;
		}


	}

}
